<?xml version='1.1' encoding='UTF-8'?>
<xwikidoc version="1.3" reference="Projects.MoRoP.ROS GettingStarted.ROS service.WebHome" locale="">
  <web>Projects.MoRoP.ROS GettingStarted.ROS service</web>
  <name>WebHome</name>
  <language/>
  <defaultLanguage>en</defaultLanguage>
  <translation>0</translation>
  <creator>XWiki.DavidDudzik</creator>
  <creationDate>1545220035000</creationDate>
  <versions>head	13.1;
access;
symbols;
locks; strict;
comment	@# @;


13.1
date	2019.02.21.09.47.58;	author XWiki_2EDavidDudzik;	state full;
branches;
next	12.1;

12.1
date	2019.02.21.09.45.50;	author XWiki_2EDavidDudzik;	state diff;
branches;
next	11.1;

11.1
date	2019.02.21.09.42.35;	author XWiki_2EDavidDudzik;	state diff;
branches;
next	10.1;

10.1
date	2019.02.21.09.40.20;	author XWiki_2EDavidDudzik;	state diff;
branches;
next	9.1;

9.1
date	2019.02.21.09.35.40;	author XWiki_2EDavidDudzik;	state full;
branches;
next	8.1;

8.1
date	2018.12.19.12.49.13;	author XWiki_2EDavidDudzik;	state diff;
branches;
next	7.2;

7.2
date	2018.12.19.12.41.56;	author XWiki_2EDavidDudzik;	state diff;
branches;
next	7.1;

7.1
date	2018.12.19.12.27.12;	author XWiki_2EDavidDudzik;	state diff;
branches;
next	6.1;

6.1
date	2018.12.19.12.23.09;	author XWiki_2EDavidDudzik;	state diff;
branches;
next	5.1;

5.1
date	2018.12.19.12.13.59;	author XWiki_2EDavidDudzik;	state full;
branches;
next	4.1;

4.1
date	2018.12.19.12.08.50;	author XWiki_2EDavidDudzik;	state diff;
branches;
next	3.1;

3.1
date	2018.12.19.12.00.48;	author XWiki_2EDavidDudzik;	state diff;
branches;
next	2.1;

2.1
date	2018.12.19.11.50.18;	author XWiki_2EDavidDudzik;	state diff;
branches;
next	1.1;

1.1
date	2018.12.19.11.47.15;	author XWiki_2EDavidDudzik;	state diff;
branches;
next	;


desc
@@


13.1
log
@@
text
@&lt;?xml version='1.1' encoding='UTF-8'?>
&lt;xwikidoc version="1.3" reference="Projects.MoRoP.ROS GettingStarted.ROS service.WebHome" locale="">
  &lt;web>Projects.MoRoP.ROS GettingStarted.ROS service&lt;/web>
  &lt;name>WebHome&lt;/name>
  &lt;language/>
  &lt;defaultLanguage>en&lt;/defaultLanguage>
  &lt;translation>0&lt;/translation>
  &lt;creator>XWiki.DavidDudzik&lt;/creator>
  &lt;creationDate>1545220035000&lt;/creationDate>
  &lt;parent>Projects.MoRoP.ROS GettingStarted.WebHome&lt;/parent>
  &lt;author>XWiki.DavidDudzik&lt;/author>
  &lt;contentAuthor>XWiki.DavidDudzik&lt;/contentAuthor>
  &lt;date>1550742478000&lt;/date>
  &lt;contentUpdateDate>1550742350000&lt;/contentUpdateDate>
  &lt;version>13.1&lt;/version>
  &lt;title>ROS service&lt;/title>
  &lt;comment/>
  &lt;minorEdit>false&lt;/minorEdit>
  &lt;syntaxId>xwiki/2.1&lt;/syntaxId>
  &lt;hidden>false&lt;/hidden>
  &lt;content>**Sitemap**

----


{{toc start="2"/}}





== Ros service ==

----

Until now, the communication between two nodes was based on messages, that where published under topics. This is the best way for a continous informationstream or data-exchange. But when there is asynchronous task to do, then there are far better solutions.
The simplest solution in ROS is called "service". A service relies on a request-response-system. That means, one node is sending an service-request to a second node, that is offering a service. The second node is doing the task and then sends a response to the first node, whether the task has failed or suceeded.


(% style="text-align:center" %)
[[image:ros_service_basic_struture.png||alt="Fig.1: ROS service basic structure"]]

{{{Fig.1: ROS service basic structure}}}

Mostly services are called by nodes, but now and then it is helpful to call service from the terminal. To get an impression how a service works, usually in the background, a service is going to be called by hand.

First, two terminals are necessary. In terminal one a (% class="mark" %)roscore(%%) has to be launched. In the second terminal a node will be started:


(% class="box infomessage" %)
(((
$ rosrun turtlesim turtlesim_node
)))

After this, run the command

(% class="box infomessage" %)
(((
$ rosservice list
)))

in a third terminal.
Executing this command will show an output similar to this:

(% class="box infomessage" %)
(((
$ rosservice list
/clear
/kill
/reset
/rosout/get_loggers
/rosout/set_logger_level
/spawn
/turtle1/set_pen
/turtle1/teleport_absolute
/turtle1/teleport_relative
/turtlesim/get_loggers
/turtlesim/set_logger_level
)))

At first glance, there are some services that are binded to a specific namespace and others that are located in the root namespace. But every service is provided by a node, so at first it is interesting to which node the services in the root namespace belong to.
To find this out, type in the above command extend by the option (% class="mark" %)-n(%%).

(% class="box infomessage" %)
(((
$ rosservice list -n
)))

 The output is almost the same as before, but now every service in the list is extended by the node that provides it1.
To get more detailed information to a service, use

(% class="box infomessage" %)
(((
$ rosservice info &amp;lt;service-name>
)))

 The output for the service /kill is:

(% class="box infomessage" %)
(((
$ rosservice info /kill
   Node: /turtlesim
   URI: rosrpc:~/~/ubuntu-ros:37541
   Type: turtlesim/Kill
   Args: name
)))

The node that provides this service is the node /turtlesim with the URI rosrpc:~/~/ubuntu-ros:375412. The type of the service is (% class="mark" %)turtlesim/kill(%%), that takes the argument(% class="mark" %) name.(%%)
There are a lot of service-types in ROS. Some service-types are basic datatypes, but others are a structure of basic datatypes or complex datatypes nested in each other. So, it can be very difficult to discover all in- and outputs. The command

(% class="box infomessage" %)
(((
$ rossrv show &amp;lt;service-type>
)))

will help to solve this problem.

For the service-type(% class="mark" %) turtlesim/kill(%%) the output is:

(% class="box infomessage" %)
(((
$ rossrv show turtlesim/Kill
   string name
   ~-~--
)))

Everthing above the three hyphens3 are the input arguments. In this case there is just one string input argument (the name of the isntance) and no output (or returning) argument. A service-type can contain all thinkable permutations of in-and output arguments. So, it is also possible to have a service-type with no input argument and no output argument. Sending a request to a node that controls a peripherie object, may be a comprehensible scenario. The node just needs to know that the service is called and the callback-function has to be executed. The callback function will return a bool (true or false). This may be the only required information for the node, that sent the request. 



=== Call a service from the terminal ===

----

In the previous section the structure of ROS service has been discussed. Now, a service will be called with the above setup. The example will be executed with the service (% class="mark" %)/kill(%%). Previously, the command (% class="mark" %)$ rossrv show(%%) was used to get information about the necessary input arguments.
This service expects the name of the turtle, which should be removed. So the command will be something like this:

(% class="box infomessage" %)
(((
$ rosservice call /kill 'turtle1'
)))

 After executing this command, the turtle in the window will disappear. For a better understanding what happend, type in[^trouble_shooting_rqt]:

(% class="box infomessage" %)
(((
$ rqt_graph
)))

(% style="text-align:center" %)
[[image:ros_service_graph.png]]


(% class="wikigeneratedid" id="HFig.2:Outputofrqt_graphaftercallingtheservice2FSpawn" %)
(((
**Fig.2: Output of rqt_graph after calling the service /Spawn**
)))

Comparing the above figure with rqt_graph/Fig.1 will show, that the node /turtlesim did not disapper. Only the topic /turtle1/cmd_vel is removed from the graph.
To get a new turtle, without restarting the node, use the service /spawn. This might be a good task to get a bit more familiar to the concept of services in ROS. When getting issues, consulte the book A gentle introduction to ROS[^ros_intro], the usage of the service /spawn is described there very well.


=== Example 5: Server-Client-Adder ===

----

(% class="box" %)
(((
This example is inspired from the example http:~/~/wiki.ros.org/ROS/Tutorials/WritingServiceClient. The idea is taken from this tutorial, but the implementation and the description may differ in some points.
)))

 In this example, a adder based on a server-client-relation will be created. The idea is to send two integer values from the client to the server. The server calculates the sum of the two integer values and returns the sum to the client.
the first step is to create a new package with the appropriate dependencies. The proper command is:

(% class="box infomessage" %)
(((
$ catkin_create_pkg calculator roscpp std_msgs message_generation
)))

 The new generated package is called calculator. (% class="mark" %)roscpp(%%) is required to use the C++-API and message_generation will be needed for generating the service-headers during the build process[^msg_generation].


==== **srv-Typedefinition** ====

----

After succesful generation of the new package, the definition of the service is required. First, a new folder has to be created in the diretory of the package.

(% class="box infomessage" %)
(((
$ mkdir -p srv
)))

Then, open a new file with

(% class="box infomessage" %)
(((
$ gedit calc_service.srv
)))

This file will contain the definition of the service. For this example two int64 alues are chosen for the request and also a int64 value for the response. So, enter the following lines in to the editor. 

(% class="box infomessage" %)
(((
int64 a
int64 b
~-~--
int64 sum
)))

(% class="box" %)
(((
Note: The three hyphens are part of the syntax.
)))

 From this file the header will generated during the build-process.



==== **Creating the server-node** ====

----

(% class="wikigeneratedid" id="HThenexttaskiscreatingthenodes.Atfirst2Ctheservernodewillbecreated.Thistakestheresponse2Cdoessomecomputationandthenpassestheresultbacktotheclient.Thesource-codecanlooklikethis:" %)
(((
//The next task is creating the nodes. At first, the server node will be created. This takes the response, does some computation and then passes the result back to the client. The source-code can look like this~://
)))

(% class="box infomessage" %)
(((
#include "ros/ros.h"
#include "calculator/calc_srv.h"
#include &amp;lt;string>

bool add(calculator::calc_srv::Request  &amp;amp;request, calculator::calc_srv::Response &amp;amp;response){
  response.sum = request.a + request.b;
  ROS_INFO_STREAM("The two integers are: " &amp;lt;&amp;lt; request.a &amp;lt;&amp;lt; " and " &amp;lt;&amp;lt; request.b &amp;lt;&amp;lt; "\n");
  ROS_INFO_STREAM("The calculated sum is " &amp;lt;&amp;lt; response.sum &amp;lt;&amp;lt; "\n");
  return true;
}

int main(int argc, char ~*~*argv)
{  
  ros::init(argc, argv, "server");
  ros::NodeHandle n;

  ros::ServiceServer service = n.advertiseService("calculate", &amp;amp;add);  
  ROS_INFO_STREAM("Server ready.");  
  ros::spin();

  return 0;
}

 
)))

The first two lines include the required header files (% class="mark" %)ros/ros.h (%%)and the new (% class="mark" %)created calculator/calc_srv.h(%%)[^calc_header].
Following this, the function(% class="mark" %) bool add()(%%) is defined and declared. This will be used as a callback-function for the service-object. The function expects a request- and a response-object from the (% class="mark" %)class calculator::calc_srv(%%).
Inside the function, the two integers from the object req are added and passed to res.sum. Following, two info-messages are printed to the terminal telling the user what is going on.
The next step is the main-function. At first, the ROS node is initialized as usual. Then, a service-object is created with a member-function of the nodehandle. In the basic configuration it expects two arguments, a servicename and the callback-function. The servicename is chosen as calculate and the callback-function is the one created above. The info-message in the next line is not required, but it is good to know that the server is started.
(% class="mark" %)ros::spin()(%%) is already known from Example 4: Subcriber.


==== **Creating the client-node** ====

After the server-node is created successfully (but not build yet), the client-node follows. This will take the input from the commandline and pass the values to the server. After the computation in the server, the result will be passed back to the client. Then, the client will produce the output in the terminal.
So, the code for this task looks as follows:

(% class="box infomessage" %)
(((
#include "ros/ros.h"
#include "calculator/calc_srv.h"
#include &amp;lt;boost/lexical_cast.hpp>

int main(int argc, char ~*~*argv){    
\\  if (argc != 3)
  {
    ROS_WARN_STREAM("Enter two int_numbers!");
    return 1;
  }

  ros::init(argc, argv, "calc_client");
  ros::NodeHandle n;  
  ros::ServiceClient client = n.serviceClient&amp;lt;calculator::calc_srv>("calculate");  
  calculator::calc_srv srv;

try{
         srv.request.a = boost::lexical_cast&amp;lt;int>(*(argv+1));
           srv.request.b = boost::lexical_cast&amp;lt;int>(*(argv+2));
         }
  catch(const boost::bad_lexical_cast &amp;amp;){
        ROS_ERROR_STREAM("Enter only INTs!");
        return 1;
      }
\\  if (client.call(srv))
  {
      ROS_INFO_STREAM("Result is: " &amp;lt;&amp;lt; srv.response.sum &amp;lt;&amp;lt; "\n");    
  }
  else{
    ROS_ERROR_STREAM("Something went wrong. Bad response from server.");
    return 1; }
  return 0;
}

 
)))


At the top, the library(% class="mark" %) ros/ros.h" (%%)is included as usual, when using the ROS C++-API. (% class="mark" %)calculator/calc_srv.h (%%)provides the informations about the service, which was created in srv-Typedefinition. The boost-library is required for the typecast, later in the code, and the related expection handling.
The main-function starts with a logical-check on the input. (% class="mark" %)argc(%%) contains the number of values entered in the commandline. The if-statement checks for three values, but the server adds only two. On first sight this seems wrong, but the first argument (or better, the zeroth element in the array argv) is always the path where the executable is located. Considering this it is obvious, that the right numbere of argmuents is three.
After this check, the node is created with(% class="mark" %) ros::init()(%%) and(% class="mark" %) ros::NodeHandle(%%). Subsequently the service-client is created in a similiar way as the service-serve. The client-object is initialized by a memberfunction of the nodehandle. At this point it is important to choose the same servicename as the server uses. In this case the right servicename is (% class="mark" %)calculate(%%).


Afterwards an object from (% class="mark" %)calculator::calc_srv(%%) is created. This is required for the next step, where the arguments from the commandline have to be casted from C-string to integer. For this purpose the boost- library provides the (% class="mark" %)lexical_cast&amp;lt;T>()(%%)-function. This function casts the function-argument to the datatype T. If the input can not be casted as expected, the function throws an exception(% class="mark" %) boost::bad_lexical_cast(%%). So, the try-catch-instruction prevents from sending a bad commandline-input to the server.
However, when the commandline-input is correct the following if-statement is executed. In the Argument the call-function is called. The function returns a bool, so it can be used as an argument for the if-statement. If the callback-function add() returns true, the client-node writes the result to the commandline using a logging-message. Otherwise, when the callback-function returns false an error-message is printed in the terminal and the main-function returns with 1.


==== **build-process** ====

At this point the two sourcefiles have been created and stored in the src-directory inside the calculator-package. Before the build-process can start the file CMakeLists.txt has to be prepared.
At first open the CMakeLists.txt-file and uncomment the lines


(% class="box infomessage" %)
(((
add_service_files(
    FILES
 )
)))

Now add (% class="mark" %)calc_srv.srv (%%)under FILES. These lines make sure, that the .srv-file in the directory srv is considered during the build-process.

Further, the following lines have to be uncommented.

(% class="box infomessage" %)
(((
 generate_messages(
   DEPENDENCIES
 )
)))

These are required for generating the messages, that are defined inside the service-definition. In this case only standard messagetypes are used, so the only entry will be(% class="mark" %) std_msgs.(%%) This line has to be added under DEPENDENCIES.
The next step is to announce the sourcefiles to the build-process. It is important to remember, that the headerfiles calculator/calc_srv.h, which is included in both sourcefiles is not build yet. That is why it is necessary to add dependencies to the CMakeLists.txt-file. These dependencies make sure, that executables are only then be built, when the build of headerfile has finished.
The generic structure of the dependency-command is:

(% class="box infomessage" %)
(((
add_dependencies(&amp;lt;target> &amp;lt;target_dependency>)
)))

 In this case the proper command is:

(% class="box infomessage" %)
(((
add_dependencies(server calculator_generate_messages_cpp) # for the server
)))

or

(% class="box infomessage" %)
(((
add_dependencies(client calculator_generate_messages_cpp) # for the client
)))

 Maybe it seems a bit strange, that the dependency is related to message_generation and not about service-files. But message_generation works for both[^msg_and_srv]
With the knowledge from Example 2: hello-world.cpp, the following lines can be added to CMakeLists.txt:

(% class="box infomessage" %)
(((
add_executable(server src/server.cpp)
target_link_libraries(server ${catkin_LIBRARIES})
add_dependencies(server calculator_generate_messages_cpp)

add_executable(client src/client.cpp)
target_link_libraries(client ${catkin_LIBRARIES})
add_dependencies(client calculator_generate_messages_cpp)
)))

(% class="box" %)
(((
 Note: The file package.xml has not to be adjusted, because the required dependencies were added when the package was created.
)))

The verylast step is to start the build process. Switch to the top of the workspace and then execute 

(% class="box infomessage" %)
(((
catkin_make
)))


==== **Using the package** ====

After a successful build-process two executables are generated. Before they can be used a roscore has to be started. Afterwards, start the server-node with

(% class="box infomessage" %)
(((
$ rosrun calculator server
)))

and the cleint node with 

(% class="box infomessage" %)
(((
$ rosrun calculator client a b
)))

Replace a and b with integer values. For example, execute:

(% class="box infomessage" %)
(((
 $ rosrun calculator client 4 12
)))

This results in the following output in the server-terminal: 

(% class="box infomessage" %)
(((
[ INFO] [1509369925.682593826]: The two integers are: 4 and 12

[ INFO] [1509369925.682726903]: The calculated sum is 16
)))

The output in the client-terminal will be similar to: 

(% class="box infomessage" %)
(((
[ INFO] [1509369925.683124120]: Result is: 16
)))

Invalid inputs like

(% class="box infomessage" %)
(((
$ rosrun calculator client 4 xy
)))

or

(% class="box infomessage" %)
(((
$ rosrun calculator client
)))

will cause error-messages, due to the error-handling in the nodes. 


=== Example 6: Ask the master ===

----

This is another example for creating a service in a ROS-network. The node provides a service that should return the number of active topics in the ROS network.
At first a new package has to be created. The ROS C++-API is needed for sure and furthermore the standard ROS-messages. So, the command for creating the new package is (of course, this command should be executed in the source-folder of the workspace):

(% class="box infomessage" %)
(((
$ catkin_create_pkg list_topics roscpp std_msgs message_generation
)))

 The new package is called list_topics with the dependencies roscpp, message_generation and std_msgs.


==== **Define the service** ====

The next step is a new one. To define a service switch in the package folder and create a new folder called srv. Open this folder an create a new file. This file contains the definition of the service, i.e. the input and output arguments. This file will be named with "list_topics_service.srv".
Then, open the file and type in the definition of the service. The service does not need any input arguments. The output argument, what the service should return, is a single integer value. So, the definition looks like this:

(% class="box infomessage" %)
(((
~-~--
int16 number_of_topics
)))

The definition is to read as follows. Over the three hyphens there are the input argument(s). In this case it is empty, but also when it empty a messagetype will be required. This messagetype is std_msgs/Empty. Under the three hyphens are the output argument(s). As seen above, only one argument is listed. The output argument of this service is an 16bit integer called number_of_topics.
At this point the service is already defined.


==== **Creating the server** ====

After defining the service, a server that provides the service is necessary. For this purpsose change to the folder src within the package directory and create a file named "list_topics_node.cpp". The server, which provides the desired service, is created by the following code:

(% class="box infomessage" %)
(((
#include "ros/ros.h"
#include "list_topics/list_topics_service.h"

bool number_topics(list_topics::list_topics_service::Request &amp;amp;req, list_topics::list_topics_service::Response &amp;amp;res){
    ros::master::V_TopicInfo master_topics;
    ros::master::getTopics(master_topics);
    int number_t = master_topics.size();
    ROS_INFO("Topics: [%i]", (int) number_t);
    res.number = number_t;
  return true;
}

int main(int argc, char ~*~*argv)
{  
  ros::init(argc, argv, "list_topics_node");
  ros::NodeHandle handle;
\\  ros::ServiceServer service = handle.advertiseService("show_number_of_topics", &amp;amp;number_topics);
  ROS_INFO("Returning number of active topics.");
  ros::spin();

  return 0;
}
)))

At the very top, the requiered libraries are included. ros/ros.h is necessary every time when the ROS C++-API should be used. The header list_topics/list_topics_service.h includes the service-definition. That there is no such headerfile build so far should be kept in mind for the later build-process.
Further down, the callback-function, that will be executed when the service is called, is defined. The returntype is always bool. It does not matter, whether it is a function or a member function or anything else.
The body of the callback-function contains the
instructions, that will be executed when a new request arrives. At the beginning a new vectorobject from the struct V_TopicInfo is created. In the next line the function getTopics (V_TopicInfo &amp;amp;topics) writes all active topics to the vectorobject by reference. Because V_TopicInfo is just a vector of structs, the member function can be used here to return the size of the vector, which is equal to the number of active topics.
The last instruction in the callback-function is the return argument.
The main-function starts as usual with the initialization of the node. Afterwards the serive_serve is created. The ROS C++-API recommends to do this with the member function of the nodehandle.


(% class="box" %)
(((
A ServiceServer should always be created through a call to NodeHandle::advertiseService(), or copied from one that was. Once all copies of a specific ServiceServer go out of scope, the service associated with it will be unadvertised and the service callback will stop being called. (see: ros::ServiceServer Class Reference)
)))

There are several ways to implement a service. For this introductory example, the simplest option is to use a simple callback function. Only the service name and the name of the callback functions is expected.
Following, an info message that the service server is ready and the instruction to pass control to the node.
Now the node is almost ready to get build with catkin.


==== **Building the service-server** ====

Before the node can be build, the file CMakeLists.txt has to be adjusted.

(% class="box infomessage" %)
(((
cmake_minimum_required(VERSION 2.8.3)
project(list_topics)

find_package(catkin REQUIRED COMPONENTS
  message_generation
  roscpp
  std_msgs
)

add_service_files(
    FILES
      list_topics_service.srv
                )


 generate_messages(
   DEPENDENCIES
   std_msgs
                )

include_directories(
  ${catkin_INCLUDE_DIRS}
)


add_executable(list_topics_node src/list_topics_node.cpp)
target_link_libraries(list_topics_node ${catkin_LIBRARIES})
add_dependencies(list_topics_node list_topics_generate_messages_cpp)
)))

The required components have been added when the package has been created (see above). At first, catkin has to know that it has to create headerfiles from the service definition. This can be declared in section add_service_files. Further the message-dependencies have to be declared. As a reminder, the service definition is a composition of messages. In this case two standard messages are used. So, In section `generate_messages the entry std_msgs has to be made.
After including the catkin directory and adding the executable (see also: example-2-hello-worldcpp), a dependency has to be added, that the service header have to be build before building the executable. Otherwise the build process will throw an error.
After editing the CMakeLists.txt file the build process can start:

(% class="box infomessage" %)
(((
$ catkin_make
)))

(% class="box" %)
(((
Note: Usually the manifest package.xml has to be edited as well. But in this case, the required dependencies have been added by using the catkin_create_pkg command with the proper dependencies.
)))



==== **Using the package** ====

The service is quite simple to use. Open up three terminals and start a roscore in the first one. Than start with

(% class="box infomessage" %)
(((
$ rosrun list_topics list_topics_node
)))

the service-server node.
The last step is to call the service. With knowledge from the previous chapter, the command

(% class="box infomessage" %)
(((
$ rosservice call /show_number_of_topics
)))

should be familiar.



=== Further Examples ===

(% class="box" %)
(((
As said in the introduction, this is designed as rolling release. So, the number of examples and/or other sections will increase in future.
)))

==== **Spawn a turtle with a service** ====

Another good described example can be found in this free-of-charge book in chapter 8.3. In this example the author describes how to implement a node, that calls the service /spawn provided by the node /turtlesim_node. The proceeding is similar to the above one, but it may be a good exersise to implement it on your own.

1. Note: Calling(% class="mark" %) $ rosnode info &amp;lt;node-name>(%%) will return the services provided by the node. ROS nodes
1. rosrpc stands for ROS-~_~_R~_~_emote ~_~_P~_~_rocedure ~_~_C~_~_all
1. The hyphens are not optional, rather part of the syntax.&lt;/content>
  &lt;attachment>
    &lt;filename>ros_service_basic_struture.png&lt;/filename>
    &lt;author>XWiki.DavidDudzik&lt;/author>
    &lt;date>1545220217000&lt;/date>
    &lt;version>1.1&lt;/version>
    &lt;comment/>
    &lt;filesize>8991&lt;/filesize>
  &lt;/attachment>
  &lt;attachment>
    &lt;filename>ros_service_graph.png&lt;/filename>
    &lt;author>XWiki.DavidDudzik&lt;/author>
    &lt;date>1545220848000&lt;/date>
    &lt;version>1.1&lt;/version>
    &lt;comment/>
    &lt;filesize>35423&lt;/filesize>
  &lt;/attachment>
&lt;/xwikidoc>@


12.1
log
@@
text
@d13 1
a13 1
  &lt;date>1550742350000&lt;/date>
d15 1
a15 1
  &lt;version>12.1&lt;/version>
@


11.1
log
@@
text
@d13 3
a15 3
  &lt;date>1550742155000&lt;/date>
  &lt;contentUpdateDate>1550742155000&lt;/contentUpdateDate>
  &lt;version>11.1&lt;/version>
d21 1
a21 1
  &lt;content>== Ros service ==
a24 1
Sitemap
a25 1

d29 3
@


10.1
log
@@
text
@d13 3
a15 3
  &lt;date>1550742020000&lt;/date>
  &lt;contentUpdateDate>1550742020000&lt;/contentUpdateDate>
  &lt;version>10.1&lt;/version>
d21 590
a610 587
  &lt;content>== Ros service ==&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
Sitemap&amp;#xd;
&amp;#xd;
&amp;#xd;
{{toc start="2"/}}&amp;#xd;
&amp;#xd;
&amp;#xd;
== Ros service ==&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
Until now, the communication between two nodes was based on messages, that where published under topics. This is the best way for a continous informationstream or data-exchange. But when there is asynchronous task to do, then there are far better solutions.&amp;#xd;
The simplest solution in ROS is called "service". A service relies on a request-response-system. That means, one node is sending an service-request to a second node, that is offering a service. The second node is doing the task and then sends a response to the first node, whether the task has failed or suceeded.&amp;#xd;
&amp;#xd;
&amp;#xd;
(% style="text-align:center" %)&amp;#xd;
[[image:ros_service_basic_struture.png||alt="Fig.1: ROS service basic structure"]]&amp;#xd;
&amp;#xd;
{{{Fig.1: ROS service basic structure}}}&amp;#xd;
&amp;#xd;
Mostly services are called by nodes, but now and then it is helpful to call service from the terminal. To get an impression how a service works, usually in the background, a service is going to be called by hand.&amp;#xd;
&amp;#xd;
First, two terminals are necessary. In terminal one a (% class="mark" %)roscore(%%) has to be launched. In the second terminal a node will be started:&amp;#xd;
&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosrun turtlesim turtlesim_node&amp;#xd;
)))&amp;#xd;
&amp;#xd;
After this, run the command&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice list&amp;#xd;
)))&amp;#xd;
&amp;#xd;
in a third terminal.&amp;#xd;
Executing this command will show an output similar to this:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice list&amp;#xd;
/clear&amp;#xd;
/kill&amp;#xd;
/reset&amp;#xd;
/rosout/get_loggers&amp;#xd;
/rosout/set_logger_level&amp;#xd;
/spawn&amp;#xd;
/turtle1/set_pen&amp;#xd;
/turtle1/teleport_absolute&amp;#xd;
/turtle1/teleport_relative&amp;#xd;
/turtlesim/get_loggers&amp;#xd;
/turtlesim/set_logger_level&amp;#xd;
)))&amp;#xd;
&amp;#xd;
At first glance, there are some services that are binded to a specific namespace and others that are located in the root namespace. But every service is provided by a node, so at first it is interesting to which node the services in the root namespace belong to.&amp;#xd;
To find this out, type in the above command extend by the option (% class="mark" %)-n(%%).&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice list -n&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 The output is almost the same as before, but now every service in the list is extended by the node that provides it1.&amp;#xd;
To get more detailed information to a service, use&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice info &amp;lt;service-name>&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 The output for the service /kill is:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice info /kill&amp;#xd;
   Node: /turtlesim&amp;#xd;
   URI: rosrpc:~/~/ubuntu-ros:37541&amp;#xd;
   Type: turtlesim/Kill&amp;#xd;
   Args: name&amp;#xd;
)))&amp;#xd;
&amp;#xd;
The node that provides this service is the node /turtlesim with the URI rosrpc:~/~/ubuntu-ros:375412. The type of the service is (% class="mark" %)turtlesim/kill(%%), that takes the argument(% class="mark" %) name.(%%)&amp;#xd;
There are a lot of service-types in ROS. Some service-types are basic datatypes, but others are a structure of basic datatypes or complex datatypes nested in each other. So, it can be very difficult to discover all in- and outputs. The command&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rossrv show &amp;lt;service-type>&amp;#xd;
)))&amp;#xd;
&amp;#xd;
will help to solve this problem.&amp;#xd;
&amp;#xd;
For the service-type(% class="mark" %) turtlesim/kill(%%) the output is:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rossrv show turtlesim/Kill&amp;#xd;
   string name&amp;#xd;
   ~-~--&amp;#xd;
)))&amp;#xd;
&amp;#xd;
Everthing above the three hyphens3 are the input arguments. In this case there is just one string input argument (the name of the isntance) and no output (or returning) argument. A service-type can contain all thinkable permutations of in-and output arguments. So, it is also possible to have a service-type with no input argument and no output argument. Sending a request to a node that controls a peripherie object, may be a comprehensible scenario. The node just needs to know that the service is called and the callback-function has to be executed. The callback function will return a bool (true or false). This may be the only required information for the node, that sent the request. &amp;#xd;
&amp;#xd;
&amp;#xd;
&amp;#xd;
=== Call a service from the terminal ===&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
In the previous section the structure of ROS service has been discussed. Now, a service will be called with the above setup. The example will be executed with the service (% class="mark" %)/kill(%%). Previously, the command (% class="mark" %)$ rossrv show(%%) was used to get information about the necessary input arguments.&amp;#xd;
This service expects the name of the turtle, which should be removed. So the command will be something like this:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice call /kill 'turtle1'&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 After executing this command, the turtle in the window will disappear. For a better understanding what happend, type in[^trouble_shooting_rqt]:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rqt_graph&amp;#xd;
)))&amp;#xd;
&amp;#xd;
(% style="text-align:center" %)&amp;#xd;
[[image:ros_service_graph.png]]&amp;#xd;
&amp;#xd;
&amp;#xd;
(% id="HFig.2:Outputofrqt_graphaftercallingtheservice2FSpawn" class="wikigeneratedid" %)&amp;#xd;
(((&amp;#xd;
**Fig.2: Output of rqt_graph after calling the service /Spawn**&amp;#xd;
)))&amp;#xd;
&amp;#xd;
Comparing the above figure with rqt_graph/Fig.1 will show, that the node /turtlesim did not disapper. Only the topic /turtle1/cmd_vel is removed from the graph.&amp;#xd;
To get a new turtle, without restarting the node, use the service /spawn. This might be a good task to get a bit more familiar to the concept of services in ROS. When getting issues, consulte the book A gentle introduction to ROS[^ros_intro], the usage of the service /spawn is described there very well.&amp;#xd;
&amp;#xd;
&amp;#xd;
=== Example 5: Server-Client-Adder ===&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
(% class="box" %)&amp;#xd;
(((&amp;#xd;
This example is inspired from the example http:~/~/wiki.ros.org/ROS/Tutorials/WritingServiceClient. The idea is taken from this tutorial, but the implementation and the description may differ in some points.&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 In this example, a adder based on a server-client-relation will be created. The idea is to send two integer values from the client to the server. The server calculates the sum of the two integer values and returns the sum to the client.&amp;#xd;
the first step is to create a new package with the appropriate dependencies. The proper command is:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ catkin_create_pkg calculator roscpp std_msgs message_generation&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 The new generated package is called calculator. (% class="mark" %)roscpp(%%) is required to use the C++-API and message_generation will be needed for generating the service-headers during the build process[^msg_generation].&amp;#xd;
&amp;#xd;
&amp;#xd;
==== **srv-Typedefinition** ====&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
After succesful generation of the new package, the definition of the service is required. First, a new folder has to be created in the diretory of the package.&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ mkdir -p srv&amp;#xd;
)))&amp;#xd;
&amp;#xd;
Then, open a new file with&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ gedit calc_service.srv&amp;#xd;
)))&amp;#xd;
&amp;#xd;
This file will contain the definition of the service. For this example two int64 alues are chosen for the request and also a int64 value for the response. So, enter the following lines in to the editor. &amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
int64 a&amp;#xd;
int64 b&amp;#xd;
~-~--&amp;#xd;
int64 sum&amp;#xd;
)))&amp;#xd;
&amp;#xd;
(% class="box" %)&amp;#xd;
(((&amp;#xd;
Note: The three hyphens are part of the syntax.&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 From this file the header will generated during the build-process.&amp;#xd;
&amp;#xd;
&amp;#xd;
&amp;#xd;
==== **Creating the server-node** ====&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
===== The next task is creating the nodes. At first, the server node will be created. This takes the response, does some computation and then passes the result back to the client. The source-code can look like this: =====&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
#include "ros/ros.h"&amp;#xd;
#include "calculator/calc_srv.h"&amp;#xd;
#include &amp;lt;string>&amp;#xd;
&amp;#xd;
bool add(calculator::calc_srv::Request  &amp;amp;request, calculator::calc_srv::Response &amp;amp;response){&amp;#xd;
  response.sum = request.a + request.b;&amp;#xd;
  ROS_INFO_STREAM("The two integers are: " &amp;lt;&amp;lt; request.a &amp;lt;&amp;lt; " and " &amp;lt;&amp;lt; request.b &amp;lt;&amp;lt; "\n");&amp;#xd;
  ROS_INFO_STREAM("The calculated sum is " &amp;lt;&amp;lt; response.sum &amp;lt;&amp;lt; "\n");&amp;#xd;
  return true;&amp;#xd;
}&amp;#xd;
&amp;#xd;
int main(int argc, char ~*~*argv)&amp;#xd;
{  &amp;#xd;
  ros::init(argc, argv, "server");&amp;#xd;
  ros::NodeHandle n;&amp;#xd;
&amp;#xd;
  ros::ServiceServer service = n.advertiseService("calculate", &amp;amp;add);  &amp;#xd;
  ROS_INFO_STREAM("Server ready.");  &amp;#xd;
  ros::spin();&amp;#xd;
&amp;#xd;
  return 0;&amp;#xd;
}&amp;#xd;
&amp;#xd;
 &amp;#xd;
)))&amp;#xd;
&amp;#xd;
The first two lines include the required header files (% class="mark" %)ros/ros.h (%%)and the new (% class="mark" %)created calculator/calc_srv.h(%%)[^calc_header].&amp;#xd;
Following this, the function(% class="mark" %) bool add()(%%) is defined and declared. This will be used as a callback-function for the service-object. The function expects a request- and a response-object from the (% class="mark" %)class calculator::calc_srv(%%).&amp;#xd;
Inside the function, the two integers from the object req are added and passed to res.sum. Following, two info-messages are printed to the terminal telling the user what is going on.&amp;#xd;
The next step is the main-function. At first, the ROS node is initialized as usual. Then, a service-object is created with a member-function of the nodehandle. In the basic configuration it expects two arguments, a servicename and the callback-function. The servicename is chosen as calculate and the callback-function is the one created above. The info-message in the next line is not required, but it is good to know that the server is started.&amp;#xd;
(% class="mark" %)ros::spin()(%%) is already known from Example 4: Subcriber.&amp;#xd;
&amp;#xd;
&amp;#xd;
==== **Creating the client-node** ====&amp;#xd;
&amp;#xd;
After the server-node is created successfully (but not build yet), the client-node follows. This will take the input from the commandline and pass the values to the server. After the computation in the server, the result will be passed back to the client. Then, the client will produce the output in the terminal.&amp;#xd;
So, the code for this task looks as follows:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
#include "ros/ros.h"&amp;#xd;
#include "calculator/calc_srv.h"&amp;#xd;
#include &amp;lt;boost/lexical_cast.hpp>&amp;#xd;
&amp;#xd;
int main(int argc, char ~*~*argv){    &amp;#xd;
\\  if (argc != 3)&amp;#xd;
  {&amp;#xd;
    ROS_WARN_STREAM("Enter two int_numbers!");&amp;#xd;
    return 1;&amp;#xd;
  }&amp;#xd;
&amp;#xd;
  ros::init(argc, argv, "calc_client");&amp;#xd;
  ros::NodeHandle n;  &amp;#xd;
  ros::ServiceClient client = n.serviceClient&amp;lt;calculator::calc_srv>("calculate");  &amp;#xd;
  calculator::calc_srv srv;&amp;#xd;
&amp;#xd;
try{&amp;#xd;
         srv.request.a = boost::lexical_cast&amp;lt;int>(*(argv+1));&amp;#xd;
           srv.request.b = boost::lexical_cast&amp;lt;int>(*(argv+2));&amp;#xd;
         }&amp;#xd;
  catch(const boost::bad_lexical_cast &amp;amp;){&amp;#xd;
        ROS_ERROR_STREAM("Enter only INTs!");&amp;#xd;
        return 1;&amp;#xd;
      }&amp;#xd;
\\  if (client.call(srv))&amp;#xd;
  {&amp;#xd;
      ROS_INFO_STREAM("Result is: " &amp;lt;&amp;lt; srv.response.sum &amp;lt;&amp;lt; "\n");    &amp;#xd;
  }&amp;#xd;
  else{&amp;#xd;
    ROS_ERROR_STREAM("Something went wrong. Bad response from server.");&amp;#xd;
    return 1; }&amp;#xd;
  return 0;&amp;#xd;
}&amp;#xd;
&amp;#xd;
 &amp;#xd;
)))&amp;#xd;
&amp;#xd;
&amp;#xd;
At the top, the library(% class="mark" %) ros/ros.h" (%%)is included as usual, when using the ROS C++-API. (% class="mark" %)calculator/calc_srv.h (%%)provides the informations about the service, which was created in srv-Typedefinition. The boost-library is required for the typecast, later in the code, and the related expection handling.&amp;#xd;
The main-function starts with a logical-check on the input. (% class="mark" %)argc(%%) contains the number of values entered in the commandline. The if-statement checks for three values, but the server adds only two. On first sight this seems wrong, but the first argument (or better, the zeroth element in the array argv) is always the path where the executable is located. Considering this it is obvious, that the right numbere of argmuents is three.&amp;#xd;
After this check, the node is created with(% class="mark" %) ros::init()(%%) and(% class="mark" %) ros::NodeHandle(%%). Subsequently the service-client is created in a similiar way as the service-serve. The client-object is initialized by a memberfunction of the nodehandle. At this point it is important to choose the same servicename as the server uses. In this case the right servicename is (% class="mark" %)calculate(%%).&amp;#xd;
&amp;#xd;
&amp;#xd;
Afterwards an object from (% class="mark" %)calculator::calc_srv(%%) is created. This is required for the next step, where the arguments from the commandline have to be casted from C-string to integer. For this purpose the boost- library provides the (% class="mark" %)lexical_cast&amp;lt;T>()(%%)-function. This function casts the function-argument to the datatype T. If the input can not be casted as expected, the function throws an exception(% class="mark" %) boost::bad_lexical_cast(%%). So, the try-catch-instruction prevents from sending a bad commandline-input to the server.&amp;#xd;
However, when the commandline-input is correct the following if-statement is executed. In the Argument the call-function is called. The function returns a bool, so it can be used as an argument for the if-statement. If the callback-function add() returns true, the client-node writes the result to the commandline using a logging-message. Otherwise, when the callback-function returns false an error-message is printed in the terminal and the main-function returns with 1.&amp;#xd;
&amp;#xd;
&amp;#xd;
==== **build-process** ====&amp;#xd;
&amp;#xd;
At this point the two sourcefiles have been created and stored in the src-directory inside the calculator-package. Before the build-process can start the file CMakeLists.txt has to be prepared.&amp;#xd;
At first open the CMakeLists.txt-file and uncomment the lines&amp;#xd;
&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
add_service_files(&amp;#xd;
    FILES&amp;#xd;
 )&amp;#xd;
)))&amp;#xd;
&amp;#xd;
Now add (% class="mark" %)calc_srv.srv (%%)under FILES. These lines make sure, that the .srv-file in the directory srv is considered during the build-process.&amp;#xd;
&amp;#xd;
Further, the following lines have to be uncommented.&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
 generate_messages(&amp;#xd;
   DEPENDENCIES&amp;#xd;
 )&amp;#xd;
)))&amp;#xd;
&amp;#xd;
These are required for generating the messages, that are defined inside the service-definition. In this case only standard messagetypes are used, so the only entry will be(% class="mark" %) std_msgs.(%%) This line has to be added under DEPENDENCIES.&amp;#xd;
The next step is to announce the sourcefiles to the build-process. It is important to remember, that the headerfiles calculator/calc_srv.h, which is included in both sourcefiles is not build yet. That is why it is necessary to add dependencies to the CMakeLists.txt-file. These dependencies make sure, that executables are only then be built, when the build of headerfile has finished.&amp;#xd;
The generic structure of the dependency-command is:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
add_dependencies(&amp;lt;target> &amp;lt;target_dependency>)&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 In this case the proper command is:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
add_dependencies(server calculator_generate_messages_cpp) # for the server&amp;#xd;
)))&amp;#xd;
&amp;#xd;
or&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
add_dependencies(client calculator_generate_messages_cpp) # for the client&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 Maybe it seems a bit strange, that the dependency is related to message_generation and not about service-files. But message_generation works for both[^msg_and_srv]&amp;#xd;
With the knowledge from Example 2: hello-world.cpp, the following lines can be added to CMakeLists.txt:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
add_executable(server src/server.cpp)&amp;#xd;
target_link_libraries(server ${catkin_LIBRARIES})&amp;#xd;
add_dependencies(server calculator_generate_messages_cpp)&amp;#xd;
&amp;#xd;
add_executable(client src/client.cpp)&amp;#xd;
target_link_libraries(client ${catkin_LIBRARIES})&amp;#xd;
add_dependencies(client calculator_generate_messages_cpp)&amp;#xd;
)))&amp;#xd;
&amp;#xd;
(% class="box" %)&amp;#xd;
(((&amp;#xd;
 Note: The file package.xml has not to be adjusted, because the required dependencies were added when the package was created.&amp;#xd;
)))&amp;#xd;
&amp;#xd;
The verylast step is to start the build process. Switch to the top of the workspace and then execute &amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
catkin_make&amp;#xd;
)))&amp;#xd;
&amp;#xd;
&amp;#xd;
==== **Using the package** ====&amp;#xd;
&amp;#xd;
After a successful build-process two executables are generated. Before they can be used a roscore has to be started. Afterwards, start the server-node with&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosrun calculator server&amp;#xd;
)))&amp;#xd;
&amp;#xd;
and the cleint node with &amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosrun calculator client a b&amp;#xd;
)))&amp;#xd;
&amp;#xd;
Replace a and b with integer values. For example, execute:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
 $ rosrun calculator client 4 12&amp;#xd;
)))&amp;#xd;
&amp;#xd;
This results in the following output in the server-terminal: &amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
[ INFO] [1509369925.682593826]: The two integers are: 4 and 12&amp;#xd;
&amp;#xd;
[ INFO] [1509369925.682726903]: The calculated sum is 16&amp;#xd;
)))&amp;#xd;
&amp;#xd;
The output in the client-terminal will be similar to: &amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
[ INFO] [1509369925.683124120]: Result is: 16&amp;#xd;
)))&amp;#xd;
&amp;#xd;
Invalid inputs like&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosrun calculator client 4 xy&amp;#xd;
)))&amp;#xd;
&amp;#xd;
or&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosrun calculator client&amp;#xd;
)))&amp;#xd;
&amp;#xd;
will cause error-messages, due to the error-handling in the nodes. &amp;#xd;
&amp;#xd;
&amp;#xd;
=== Example 6: Ask the master ===&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
This is another example for creating a service in a ROS-network. The node provides a service that should return the number of active topics in the ROS network.&amp;#xd;
At first a new package has to be created. The ROS C++-API is needed for sure and furthermore the standard ROS-messages. So, the command for creating the new package is (of course, this command should be executed in the source-folder of the workspace):&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ catkin_create_pkg list_topics roscpp std_msgs message_generation&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 The new package is called list_topics with the dependencies roscpp, message_generation and std_msgs.&amp;#xd;
&amp;#xd;
&amp;#xd;
==== **Define the service** ====&amp;#xd;
&amp;#xd;
The next step is a new one. To define a service switch in the package folder and create a new folder called srv. Open this folder an create a new file. This file contains the definition of the service, i.e. the input and output arguments. This file will be named with "list_topics_service.srv".&amp;#xd;
Then, open the file and type in the definition of the service. The service does not need any input arguments. The output argument, what the service should return, is a single integer value. So, the definition looks like this:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
~-~--&amp;#xd;
int16 number_of_topics&amp;#xd;
)))&amp;#xd;
&amp;#xd;
The definition is to read as follows. Over the three hyphens there are the input argument(s). In this case it is empty, but also when it empty a messagetype will be required. This messagetype is std_msgs/Empty. Under the three hyphens are the output argument(s). As seen above, only one argument is listed. The output argument of this service is an 16bit integer called number_of_topics.&amp;#xd;
At this point the service is already defined.&amp;#xd;
&amp;#xd;
&amp;#xd;
==== **Creating the server** ====&amp;#xd;
&amp;#xd;
After defining the service, a server that provides the service is necessary. For this purpsose change to the folder src within the package directory and create a file named "list_topics_node.cpp". The server, which provides the desired service, is created by the following code:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
#include "ros/ros.h"&amp;#xd;
#include "list_topics/list_topics_service.h"&amp;#xd;
&amp;#xd;
bool number_topics(list_topics::list_topics_service::Request &amp;amp;req, list_topics::list_topics_service::Response &amp;amp;res){&amp;#xd;
    ros::master::V_TopicInfo master_topics;&amp;#xd;
    ros::master::getTopics(master_topics);&amp;#xd;
    int number_t = master_topics.size();&amp;#xd;
    ROS_INFO("Topics: [%i]", (int) number_t);&amp;#xd;
    res.number = number_t;&amp;#xd;
  return true;&amp;#xd;
}&amp;#xd;
&amp;#xd;
int main(int argc, char ~*~*argv)&amp;#xd;
{  &amp;#xd;
  ros::init(argc, argv, "list_topics_node");&amp;#xd;
  ros::NodeHandle handle;&amp;#xd;
\\  ros::ServiceServer service = handle.advertiseService("show_number_of_topics", &amp;amp;number_topics);&amp;#xd;
  ROS_INFO("Returning number of active topics.");&amp;#xd;
  ros::spin();&amp;#xd;
&amp;#xd;
  return 0;&amp;#xd;
}&amp;#xd;
)))&amp;#xd;
&amp;#xd;
At the very top, the requiered libraries are included. ros/ros.h is necessary every time when the ROS C++-API should be used. The header list_topics/list_topics_service.h includes the service-definition. That there is no such headerfile build so far should be kept in mind for the later build-process.&amp;#xd;
Further down, the callback-function, that will be executed when the service is called, is defined. The returntype is always bool. It does not matter, whether it is a function or a member function or anything else.&amp;#xd;
The body of the callback-function contains the&amp;#xd;
instructions, that will be executed when a new request arrives. At the beginning a new vectorobject from the struct V_TopicInfo is created. In the next line the function getTopics (V_TopicInfo &amp;amp;topics) writes all active topics to the vectorobject by reference. Because V_TopicInfo is just a vector of structs, the member function can be used here to return the size of the vector, which is equal to the number of active topics.&amp;#xd;
The last instruction in the callback-function is the return argument.&amp;#xd;
The main-function starts as usual with the initialization of the node. Afterwards the serive_serve is created. The ROS C++-API recommends to do this with the member function of the nodehandle.&amp;#xd;
&amp;#xd;
&amp;#xd;
(% class="box" %)&amp;#xd;
(((&amp;#xd;
A ServiceServer should always be created through a call to NodeHandle::advertiseService(), or copied from one that was. Once all copies of a specific ServiceServer go out of scope, the service associated with it will be unadvertised and the service callback will stop being called. (see: ros::ServiceServer Class Reference)&amp;#xd;
)))&amp;#xd;
&amp;#xd;
There are several ways to implement a service. For this introductory example, the simplest option is to use a simple callback function. Only the service name and the name of the callback functions is expected.&amp;#xd;
Following, an info message that the service server is ready and the instruction to pass control to the node.&amp;#xd;
Now the node is almost ready to get build with catkin.&amp;#xd;
&amp;#xd;
&amp;#xd;
==== **Building the service-server** ====&amp;#xd;
&amp;#xd;
Before the node can be build, the file CMakeLists.txt has to be adjusted.&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
cmake_minimum_required(VERSION 2.8.3)&amp;#xd;
project(list_topics)&amp;#xd;
&amp;#xd;
find_package(catkin REQUIRED COMPONENTS&amp;#xd;
  message_generation&amp;#xd;
  roscpp&amp;#xd;
  std_msgs&amp;#xd;
)&amp;#xd;
&amp;#xd;
add_service_files(&amp;#xd;
    FILES&amp;#xd;
      list_topics_service.srv&amp;#xd;
                )&amp;#xd;
&amp;#xd;
&amp;#xd;
 generate_messages(&amp;#xd;
   DEPENDENCIES&amp;#xd;
   std_msgs&amp;#xd;
                )&amp;#xd;
&amp;#xd;
include_directories(&amp;#xd;
  ${catkin_INCLUDE_DIRS}&amp;#xd;
)&amp;#xd;
&amp;#xd;
&amp;#xd;
add_executable(list_topics_node src/list_topics_node.cpp)&amp;#xd;
target_link_libraries(list_topics_node ${catkin_LIBRARIES})&amp;#xd;
add_dependencies(list_topics_node list_topics_generate_messages_cpp)&amp;#xd;
)))&amp;#xd;
&amp;#xd;
The required components have been added when the package has been created (see above). At first, catkin has to know that it has to create headerfiles from the service definition. This can be declared in section add_service_files. Further the message-dependencies have to be declared. As a reminder, the service definition is a composition of messages. In this case two standard messages are used. So, In section `generate_messages the entry std_msgs has to be made.&amp;#xd;
After including the catkin directory and adding the executable (see also: example-2-hello-worldcpp), a dependency has to be added, that the service header have to be build before building the executable. Otherwise the build process will throw an error.&amp;#xd;
After editing the CMakeLists.txt file the build process can start:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ catkin_make&amp;#xd;
)))&amp;#xd;
&amp;#xd;
(% class="box" %)&amp;#xd;
(((&amp;#xd;
Note: Usually the manifest package.xml has to be edited as well. But in this case, the required dependencies have been added by using the catkin_create_pkg command with the proper dependencies.&amp;#xd;
)))&amp;#xd;
&amp;#xd;
&amp;#xd;
&amp;#xd;
==== **Using the package** ====&amp;#xd;
&amp;#xd;
The service is quite simple to use. Open up three terminals and start a roscore in the first one. Than start with&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosrun list_topics list_topics_node&amp;#xd;
)))&amp;#xd;
&amp;#xd;
the service-server node.&amp;#xd;
The last step is to call the service. With knowledge from the previous chapter, the command&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice call /show_number_of_topics&amp;#xd;
)))&amp;#xd;
&amp;#xd;
should be familiar.&amp;#xd;
&amp;#xd;
&amp;#xd;
&amp;#xd;
=== Further Examples ===&amp;#xd;
&amp;#xd;
(% class="box" %)&amp;#xd;
(((&amp;#xd;
As said in the introduction, this is designed as rolling release. So, the number of examples and/or other sections will increase in future.&amp;#xd;
)))&amp;#xd;
&amp;#xd;
==== **Spawn a turtle with a service** ====&amp;#xd;
&amp;#xd;
Another good described example can be found in this free-of-charge book in chapter 8.3. In this example the author describes how to implement a node, that calls the service /spawn provided by the node /turtlesim_node. The proceeding is similar to the above one, but it may be a good exersise to implement it on your own.&amp;#xd;
&amp;#xd;
1. Note: Calling(% class="mark" %) $ rosnode info &amp;lt;node-name>(%%) will return the services provided by the node. ROS nodes&amp;#xd;
1. rosrpc stands for ROS-~_~_R~_~_emote ~_~_P~_~_rocedure ~_~_C~_~_all&amp;#xd;
@


9.1
log
@@
text
@&lt;?xml version='1.1' encoding='UTF-8'?>
&lt;xwikidoc version="1.3" reference="Projects.MoRoP.ROS GettingStarted.ROS service.WebHome" locale="">
  &lt;web>Projects.MoRoP.ROS GettingStarted.ROS service&lt;/web>
  &lt;name>WebHome&lt;/name>
  &lt;language/>
  &lt;defaultLanguage>en&lt;/defaultLanguage>
  &lt;translation>0&lt;/translation>
  &lt;creator>XWiki.DavidDudzik&lt;/creator>
  &lt;creationDate>1545220035000&lt;/creationDate>
  &lt;parent>Projects.MoRoP.ROS GettingStarted.WebHome&lt;/parent>
  &lt;author>XWiki.DavidDudzik&lt;/author>
  &lt;contentAuthor>XWiki.DavidDudzik&lt;/contentAuthor>
  &lt;date>1550741740000&lt;/date>
  &lt;contentUpdateDate>1550741740000&lt;/contentUpdateDate>
  &lt;version>9.1&lt;/version>
  &lt;title>ROS service&lt;/title>
  &lt;comment/>
  &lt;minorEdit>false&lt;/minorEdit>
  &lt;syntaxId>xwiki/2.1&lt;/syntaxId>
  &lt;hidden>false&lt;/hidden>
  &lt;content>== Ros service ==&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
Sitemap&amp;#xd;
&amp;#xd;
&amp;#xd;
{{toc start="2"/}}&amp;#xd;
&amp;#xd;
&amp;#xd;
== Ros service ==&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
Until now, the communication between two nodes was based on messages, that where published under topics. This is the best way for a continous informationstream or data-exchange. But when there is asynchronous task to do, then there are far better solutions.&amp;#xd;
The simplest solution in ROS is called "service". A service relies on a request-response-system. That means, one node is sending an service-request to a second node, that is offering a service. The second node is doing the task and then sends a response to the first node, whether the task has failed or suceeded.&amp;#xd;
&amp;#xd;
&amp;#xd;
(% style="text-align:center" %)&amp;#xd;
[[image:ros_service_basic_struture.png||alt="Fig.1: ROS service basic structure"]]&amp;#xd;
&amp;#xd;
{{{Fig.1: ROS service basic structure}}}&amp;#xd;
&amp;#xd;
Mostly services are called by nodes, but now and then it is helpful to call service from the terminal. To get an impression how a service works, usually in the background, a service is going to be called by hand.&amp;#xd;
&amp;#xd;
First, two terminals are necessary. In terminal one a (% class="mark" %)roscore(%%) has to be launched. In the second terminal a node will be started:&amp;#xd;
&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosrun turtlesim turtlesim_node&amp;#xd;
)))&amp;#xd;
&amp;#xd;
After this, run the command&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice list&amp;#xd;
)))&amp;#xd;
&amp;#xd;
in a third terminal.&amp;#xd;
Executing this command will show an output similar to this:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice list&amp;#xd;
/clear&amp;#xd;
/kill&amp;#xd;
/reset&amp;#xd;
/rosout/get_loggers&amp;#xd;
/rosout/set_logger_level&amp;#xd;
/spawn&amp;#xd;
/turtle1/set_pen&amp;#xd;
/turtle1/teleport_absolute&amp;#xd;
/turtle1/teleport_relative&amp;#xd;
/turtlesim/get_loggers&amp;#xd;
/turtlesim/set_logger_level&amp;#xd;
)))&amp;#xd;
&amp;#xd;
At first glance, there are some services that are binded to a specific namespace and others that are located in the root namespace. But every service is provided by a node, so at first it is interesting to which node the services in the root namespace belong to.&amp;#xd;
To find this out, type in the above command extend by the option (% class="mark" %)-n(%%).&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice list -n&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 The output is almost the same as before, but now every service in the list is extended by the node that provides it1.&amp;#xd;
To get more detailed information to a service, use&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice info &amp;lt;service-name>&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 The output for the service /kill is:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice info /kill&amp;#xd;
   Node: /turtlesim&amp;#xd;
   URI: rosrpc:~/~/ubuntu-ros:37541&amp;#xd;
   Type: turtlesim/Kill&amp;#xd;
   Args: name&amp;#xd;
)))&amp;#xd;
&amp;#xd;
The node that provides this service is the node /turtlesim with the URI rosrpc:~/~/ubuntu-ros:375412. The type of the service is (% class="mark" %)turtlesim/kill(%%), that takes the argument(% class="mark" %) name.(%%)&amp;#xd;
There are a lot of service-types in ROS. Some service-types are basic datatypes, but others are a structure of basic datatypes or complex datatypes nested in each other. So, it can be very difficult to discover all in- and outputs. The command&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rossrv show &amp;lt;service-type>&amp;#xd;
)))&amp;#xd;
&amp;#xd;
will help to solve this problem.&amp;#xd;
&amp;#xd;
For the service-type(% class="mark" %) turtlesim/kill(%%) the output is:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rossrv show turtlesim/Kill&amp;#xd;
   string name&amp;#xd;
   ~-~--&amp;#xd;
)))&amp;#xd;
&amp;#xd;
Everthing above the three hyphens3 are the input arguments. In this case there is just one string input argument (the name of the isntance) and no output (or returning) argument. A service-type can contain all thinkable permutations of in-and output arguments. So, it is also possible to have a service-type with no input argument and no output argument. Sending a request to a node that controls a peripherie object, may be a comprehensible scenario. The node just needs to know that the service is called and the callback-function has to be executed. The callback function will return a bool (true or false). This may be the only required information for the node, that sent the request. &amp;#xd;
&amp;#xd;
&amp;#xd;
&amp;#xd;
=== Call a service from the terminal ===&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
In the previous section the structure of ROS service has been discussed. Now, a service will be called with the above setup. The example will be executed with the service (% class="mark" %)/kill(%%). Previously, the command (% class="mark" %)$ rossrv show(%%) was used to get information about the necessary input arguments.&amp;#xd;
This service expects the name of the turtle, which should be removed. So the command will be something like this:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice call /kill 'turtle1'&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 After executing this command, the turtle in the window will disappear. For a better understanding what happend, type in[^trouble_shooting_rqt]:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rqt_graph&amp;#xd;
)))&amp;#xd;
&amp;#xd;
(% style="text-align:center" %)&amp;#xd;
[[image:ros_service_graph.png]]&amp;#xd;
&amp;#xd;
&amp;#xd;
====== **Fig.2: Output of rqt_graph after calling the service /Spawn** ======&amp;#xd;
&amp;#xd;
Comparing the above figure with rqt_graph/Fig.1 will show, that the node /turtlesim did not disapper. Only the topic /turtle1/cmd_vel is removed from the graph.&amp;#xd;
To get a new turtle, without restarting the node, use the service /spawn. This might be a good task to get a bit more familiar to the concept of services in ROS. When getting issues, consulte the book A gentle introduction to ROS[^ros_intro], the usage of the service /spawn is described there very well.&amp;#xd;
&amp;#xd;
&amp;#xd;
=== Example 5: Server-Client-Adder ===&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
(% class="box" %)&amp;#xd;
(((&amp;#xd;
This example is inspired from the example http:~/~/wiki.ros.org/ROS/Tutorials/WritingServiceClient. The idea is taken from this tutorial, but the implementation and the description may differ in some points.&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 In this example, a adder based on a server-client-relation will be created. The idea is to send two integer values from the client to the server. The server calculates the sum of the two integer values and returns the sum to the client.&amp;#xd;
the first step is to create a new package with the appropriate dependencies. The proper command is:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ catkin_create_pkg calculator roscpp std_msgs message_generation&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 The new generated package is called calculator. (% class="mark" %)roscpp(%%) is required to use the C++-API and message_generation will be needed for generating the service-headers during the build process[^msg_generation].&amp;#xd;
&amp;#xd;
&amp;#xd;
====   ====&amp;#xd;
&amp;#xd;
==== &amp;#xd;
**srv-Typedefinition** ====&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
After succesful generation of the new package, the definition of the service is required. First, a new folder has to be created in the diretory of the package.&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ mkdir -p srv&amp;#xd;
)))&amp;#xd;
&amp;#xd;
Then, open a new file with&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ gedit calc_service.srv&amp;#xd;
)))&amp;#xd;
&amp;#xd;
This file will contain the definition of the service. For this example two int64 alues are chosen for the request and also a int64 value for the response. So, enter the following lines in to the editor. &amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
int64 a&amp;#xd;
int64 b&amp;#xd;
~-~--&amp;#xd;
int64 sum&amp;#xd;
)))&amp;#xd;
&amp;#xd;
(% class="box" %)&amp;#xd;
(((&amp;#xd;
Note: The three hyphens are part of the syntax.&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 From this file the header will generated during the build-process.&amp;#xd;
&amp;#xd;
&amp;#xd;
&amp;#xd;
==== &amp;#xd;
**Creating the server-node** ====&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
===== The next task is creating the nodes. At first, the server node will be created. This takes the response, does some computation and then passes the result back to the client. The source-code can look like this: =====&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
#include "ros/ros.h"&amp;#xd;
#include "calculator/calc_srv.h"&amp;#xd;
#include &amp;lt;string>&amp;#xd;
&amp;#xd;
bool add(calculator::calc_srv::Request  &amp;amp;request, calculator::calc_srv::Response &amp;amp;response){&amp;#xd;
  response.sum = request.a + request.b;&amp;#xd;
  ROS_INFO_STREAM("The two integers are: " &amp;lt;&amp;lt; request.a &amp;lt;&amp;lt; " and " &amp;lt;&amp;lt; request.b &amp;lt;&amp;lt; "\n");&amp;#xd;
  ROS_INFO_STREAM("The calculated sum is " &amp;lt;&amp;lt; response.sum &amp;lt;&amp;lt; "\n");&amp;#xd;
  return true;&amp;#xd;
}&amp;#xd;
&amp;#xd;
int main(int argc, char ~*~*argv)&amp;#xd;
{  &amp;#xd;
  ros::init(argc, argv, "server");&amp;#xd;
  ros::NodeHandle n;&amp;#xd;
&amp;#xd;
  ros::ServiceServer service = n.advertiseService("calculate", &amp;amp;add);  &amp;#xd;
  ROS_INFO_STREAM("Server ready.");  &amp;#xd;
  ros::spin();&amp;#xd;
&amp;#xd;
  return 0;&amp;#xd;
}&amp;#xd;
&amp;#xd;
 &amp;#xd;
)))&amp;#xd;
&amp;#xd;
The first two lines include the required header files (% class="mark" %)ros/ros.h (%%)and the new (% class="mark" %)created calculator/calc_srv.h(%%)[^calc_header].&amp;#xd;
Following this, the function(% class="mark" %) bool add()(%%) is defined and declared. This will be used as a callback-function for the service-object. The function expects a request- and a response-object from the (% class="mark" %)class calculator::calc_srv(%%).&amp;#xd;
Inside the function, the two integers from the object req are added and passed to res.sum. Following, two info-messages are printed to the terminal telling the user what is going on.&amp;#xd;
The next step is the main-function. At first, the ROS node is initialized as usual. Then, a service-object is created with a member-function of the nodehandle. In the basic configuration it expects two arguments, a servicename and the callback-function. The servicename is chosen as calculate and the callback-function is the one created above. The info-message in the next line is not required, but it is good to know that the server is started.&amp;#xd;
(% class="mark" %)ros::spin()(%%) is already known from Example 4: Subcriber.&amp;#xd;
&amp;#xd;
&amp;#xd;
==== &amp;#xd;
**Creating the client-node** ====&amp;#xd;
&amp;#xd;
After the server-node is created successfully (but not build yet), the client-node follows. This will take the input from the commandline and pass the values to the server. After the computation in the server, the result will be passed back to the client. Then, the client will produce the output in the terminal.&amp;#xd;
So, the code for this task looks as follows:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
#include "ros/ros.h"&amp;#xd;
#include "calculator/calc_srv.h"&amp;#xd;
#include &amp;lt;boost/lexical_cast.hpp>&amp;#xd;
&amp;#xd;
int main(int argc, char ~*~*argv){    &amp;#xd;
\\  if (argc != 3)&amp;#xd;
  {&amp;#xd;
    ROS_WARN_STREAM("Enter two int_numbers!");&amp;#xd;
    return 1;&amp;#xd;
  }&amp;#xd;
&amp;#xd;
  ros::init(argc, argv, "calc_client");&amp;#xd;
  ros::NodeHandle n;  &amp;#xd;
  ros::ServiceClient client = n.serviceClient&amp;lt;calculator::calc_srv>("calculate");  &amp;#xd;
  calculator::calc_srv srv;&amp;#xd;
&amp;#xd;
try{&amp;#xd;
         srv.request.a = boost::lexical_cast&amp;lt;int>(*(argv+1));&amp;#xd;
           srv.request.b = boost::lexical_cast&amp;lt;int>(*(argv+2));&amp;#xd;
         }&amp;#xd;
  catch(const boost::bad_lexical_cast &amp;amp;){&amp;#xd;
        ROS_ERROR_STREAM("Enter only INTs!");&amp;#xd;
        return 1;&amp;#xd;
      }&amp;#xd;
\\  if (client.call(srv))&amp;#xd;
  {&amp;#xd;
      ROS_INFO_STREAM("Result is: " &amp;lt;&amp;lt; srv.response.sum &amp;lt;&amp;lt; "\n");    &amp;#xd;
  }&amp;#xd;
  else{&amp;#xd;
    ROS_ERROR_STREAM("Something went wrong. Bad response from server.");&amp;#xd;
    return 1; }&amp;#xd;
  return 0;&amp;#xd;
}&amp;#xd;
&amp;#xd;
 &amp;#xd;
)))&amp;#xd;
&amp;#xd;
&amp;#xd;
At the top, the library(% class="mark" %) ros/ros.h" (%%)is included as usual, when using the ROS C++-API. (% class="mark" %)calculator/calc_srv.h (%%)provides the informations about the service, which was created in srv-Typedefinition. The boost-library is required for the typecast, later in the code, and the related expection handling.&amp;#xd;
The main-function starts with a logical-check on the input. (% class="mark" %)argc(%%) contains the number of values entered in the commandline. The if-statement checks for three values, but the server adds only two. On first sight this seems wrong, but the first argument (or better, the zeroth element in the array argv) is always the path where the executable is located. Considering this it is obvious, that the right numbere of argmuents is three.&amp;#xd;
After this check, the node is created with(% class="mark" %) ros::init()(%%) and(% class="mark" %) ros::NodeHandle(%%). Subsequently the service-client is created in a similiar way as the service-serve. The client-object is initialized by a memberfunction of the nodehandle. At this point it is important to choose the same servicename as the server uses. In this case the right servicename is (% class="mark" %)calculate(%%).&amp;#xd;
&amp;#xd;
&amp;#xd;
Afterwards an object from (% class="mark" %)calculator::calc_srv(%%) is created. This is required for the next step, where the arguments from the commandline have to be casted from C-string to integer. For this purpose the boost- library provides the (% class="mark" %)lexical_cast&amp;lt;T>()(%%)-function. This function casts the function-argument to the datatype T. If the input can not be casted as expected, the function throws an exception(% class="mark" %) boost::bad_lexical_cast(%%). So, the try-catch-instruction prevents from sending a bad commandline-input to the server.&amp;#xd;
However, when the commandline-input is correct the following if-statement is executed. In the Argument the call-function is called. The function returns a bool, so it can be used as an argument for the if-statement. If the callback-function add() returns true, the client-node writes the result to the commandline using a logging-message. Otherwise, when the callback-function returns false an error-message is printed in the terminal and the main-function returns with 1.&amp;#xd;
&amp;#xd;
&amp;#xd;
==== &amp;#xd;
**build-process** ====&amp;#xd;
&amp;#xd;
At this point the two sourcefiles have been created and stored in the src-directory inside the calculator-package. Before the build-process can start the file CMakeLists.txt has to be prepared.&amp;#xd;
At first open the CMakeLists.txt-file and uncomment the lines&amp;#xd;
&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
add_service_files(&amp;#xd;
    FILES&amp;#xd;
 )&amp;#xd;
)))&amp;#xd;
&amp;#xd;
Now add (% class="mark" %)calc_srv.srv (%%)under FILES. These lines make sure, that the .srv-file in the directory srv is considered during the build-process.&amp;#xd;
&amp;#xd;
Further, the following lines have to be uncommented.&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
 generate_messages(&amp;#xd;
   DEPENDENCIES&amp;#xd;
 )&amp;#xd;
)))&amp;#xd;
&amp;#xd;
These are required for generating the messages, that are defined inside the service-definition. In this case only standard messagetypes are used, so the only entry will be(% class="mark" %) std_msgs.(%%) This line has to be added under DEPENDENCIES.&amp;#xd;
The next step is to announce the sourcefiles to the build-process. It is important to remember, that the headerfiles calculator/calc_srv.h, which is included in both sourcefiles is not build yet. That is why it is necessary to add dependencies to the CMakeLists.txt-file. These dependencies make sure, that executables are only then be built, when the build of headerfile has finished.&amp;#xd;
The generic structure of the dependency-command is:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
add_dependencies(&amp;lt;target> &amp;lt;target_dependency>)&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 In this case the proper command is:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
add_dependencies(server calculator_generate_messages_cpp) # for the server&amp;#xd;
)))&amp;#xd;
&amp;#xd;
or&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
add_dependencies(client calculator_generate_messages_cpp) # for the client&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 Maybe it seems a bit strange, that the dependency is related to message_generation and not about service-files. But message_generation works for both[^msg_and_srv]&amp;#xd;
With the knowledge from Example 2: hello-world.cpp, the following lines can be added to CMakeLists.txt:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
add_executable(server src/server.cpp)&amp;#xd;
target_link_libraries(server ${catkin_LIBRARIES})&amp;#xd;
add_dependencies(server calculator_generate_messages_cpp)&amp;#xd;
&amp;#xd;
add_executable(client src/client.cpp)&amp;#xd;
target_link_libraries(client ${catkin_LIBRARIES})&amp;#xd;
add_dependencies(client calculator_generate_messages_cpp)&amp;#xd;
)))&amp;#xd;
&amp;#xd;
(% class="box" %)&amp;#xd;
(((&amp;#xd;
 Note: The file package.xml has not to be adjusted, because the required dependencies were added when the package was created.&amp;#xd;
)))&amp;#xd;
&amp;#xd;
The verylast step is to start the build process. Switch to the top of the workspace and then execute &amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
catkin_make&amp;#xd;
)))&amp;#xd;
&amp;#xd;
&amp;#xd;
==== &amp;#xd;
**Using the package** ====&amp;#xd;
&amp;#xd;
After a successful build-process two executables are generated. Before they can be used a roscore has to be started. Afterwards, start the server-node with&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosrun calculator server&amp;#xd;
)))&amp;#xd;
&amp;#xd;
and the cleint node with &amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosrun calculator client a b&amp;#xd;
)))&amp;#xd;
&amp;#xd;
Replace a and b with integer values. For example, execute:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
 $ rosrun calculator client 4 12&amp;#xd;
)))&amp;#xd;
&amp;#xd;
This results in the following output in the server-terminal: &amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
[ INFO] [1509369925.682593826]: The two integers are: 4 and 12&amp;#xd;
&amp;#xd;
[ INFO] [1509369925.682726903]: The calculated sum is 16&amp;#xd;
)))&amp;#xd;
&amp;#xd;
The output in the client-terminal will be similar to: &amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
[ INFO] [1509369925.683124120]: Result is: 16&amp;#xd;
)))&amp;#xd;
&amp;#xd;
Invalid inputs like&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosrun calculator client 4 xy&amp;#xd;
)))&amp;#xd;
&amp;#xd;
or&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosrun calculator client&amp;#xd;
)))&amp;#xd;
&amp;#xd;
will cause error-messages, due to the error-handling in the nodes. &amp;#xd;
&amp;#xd;
&amp;#xd;
=== Example 6: Ask the master ===&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
This is another example for creating a service in a ROS-network. The node provides a service that should return the number of active topics in the ROS network.&amp;#xd;
At first a new package has to be created. The ROS C++-API is needed for sure and furthermore the standard ROS-messages. So, the command for creating the new package is (of course, this command should be executed in the source-folder of the workspace):&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ catkin_create_pkg list_topics roscpp std_msgs message_generation&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 The new package is called list_topics with the dependencies roscpp, message_generation and std_msgs.&amp;#xd;
&amp;#xd;
&amp;#xd;
==== &amp;#xd;
**Define the service** ====&amp;#xd;
&amp;#xd;
The next step is a new one. To define a service switch in the package folder and create a new folder called srv. Open this folder an create a new file. This file contains the definition of the service, i.e. the input and output arguments. This file will be named with "list_topics_service.srv".&amp;#xd;
Then, open the file and type in the definition of the service. The service does not need any input arguments. The output argument, what the service should return, is a single integer value. So, the definition looks like this:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
~-~--&amp;#xd;
int16 number_of_topics&amp;#xd;
)))&amp;#xd;
&amp;#xd;
The definition is to read as follows. Over the three hyphens there are the input argument(s). In this case it is empty, but also when it empty a messagetype will be required. This messagetype is std_msgs/Empty. Under the three hyphens are the output argument(s). As seen above, only one argument is listed. The output argument of this service is an 16bit integer called number_of_topics.&amp;#xd;
At this point the service is already defined.&amp;#xd;
&amp;#xd;
&amp;#xd;
==== &amp;#xd;
**Creating the server** ====&amp;#xd;
&amp;#xd;
After defining the service, a server that provides the service is necessary. For this purpsose change to the folder src within the package directory and create a file named "list_topics_node.cpp". The server, which provides the desired service, is created by the following code:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
#include "ros/ros.h"&amp;#xd;
#include "list_topics/list_topics_service.h"&amp;#xd;
&amp;#xd;
bool number_topics(list_topics::list_topics_service::Request &amp;amp;req, list_topics::list_topics_service::Response &amp;amp;res){&amp;#xd;
    ros::master::V_TopicInfo master_topics;&amp;#xd;
    ros::master::getTopics(master_topics);&amp;#xd;
    int number_t = master_topics.size();&amp;#xd;
    ROS_INFO("Topics: [%i]", (int) number_t);&amp;#xd;
    res.number = number_t;&amp;#xd;
  return true;&amp;#xd;
}&amp;#xd;
&amp;#xd;
int main(int argc, char ~*~*argv)&amp;#xd;
{  &amp;#xd;
  ros::init(argc, argv, "list_topics_node");&amp;#xd;
  ros::NodeHandle handle;&amp;#xd;
\\  ros::ServiceServer service = handle.advertiseService("show_number_of_topics", &amp;amp;number_topics);&amp;#xd;
  ROS_INFO("Returning number of active topics.");&amp;#xd;
  ros::spin();&amp;#xd;
&amp;#xd;
  return 0;&amp;#xd;
}&amp;#xd;
)))&amp;#xd;
&amp;#xd;
At the very top, the requiered libraries are included. ros/ros.h is necessary every time when the ROS C++-API should be used. The header list_topics/list_topics_service.h includes the service-definition. That there is no such headerfile build so far should be kept in mind for the later build-process.&amp;#xd;
Further down, the callback-function, that will be executed when the service is called, is defined. The returntype is always bool. It does not matter, whether it is a function or a member function or anything else.&amp;#xd;
The body of the callback-function contains the&amp;#xd;
instructions, that will be executed when a new request arrives. At the beginning a new vectorobject from the struct V_TopicInfo is created. In the next line the function getTopics (V_TopicInfo &amp;amp;topics) writes all active topics to the vectorobject by reference. Because V_TopicInfo is just a vector of structs, the member function can be used here to return the size of the vector, which is equal to the number of active topics.&amp;#xd;
The last instruction in the callback-function is the return argument.&amp;#xd;
The main-function starts as usual with the initialization of the node. Afterwards the serive_serve is created. The ROS C++-API recommends to do this with the member function of the nodehandle.&amp;#xd;
&amp;#xd;
&amp;#xd;
(% class="box" %)&amp;#xd;
(((&amp;#xd;
A ServiceServer should always be created through a call to NodeHandle::advertiseService(), or copied from one that was. Once all copies of a specific ServiceServer go out of scope, the service associated with it will be unadvertised and the service callback will stop being called. (see: ros::ServiceServer Class Reference)&amp;#xd;
)))&amp;#xd;
&amp;#xd;
There are several ways to implement a service. For this introductory example, the simplest option is to use a simple callback function. Only the service name and the name of the callback functions is expected.&amp;#xd;
Following, an info message that the service server is ready and the instruction to pass control to the node.&amp;#xd;
Now the node is almost ready to get build with catkin.&amp;#xd;
&amp;#xd;
&amp;#xd;
==== &amp;#xd;
**Building the service-server** ====&amp;#xd;
&amp;#xd;
Before the node can be build, the file CMakeLists.txt has to be adjusted.&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
cmake_minimum_required(VERSION 2.8.3)&amp;#xd;
project(list_topics)&amp;#xd;
&amp;#xd;
find_package(catkin REQUIRED COMPONENTS&amp;#xd;
  message_generation&amp;#xd;
  roscpp&amp;#xd;
  std_msgs&amp;#xd;
)&amp;#xd;
&amp;#xd;
add_service_files(&amp;#xd;
    FILES&amp;#xd;
      list_topics_service.srv&amp;#xd;
                )&amp;#xd;
&amp;#xd;
&amp;#xd;
 generate_messages(&amp;#xd;
   DEPENDENCIES&amp;#xd;
   std_msgs&amp;#xd;
                )&amp;#xd;
&amp;#xd;
include_directories(&amp;#xd;
  ${catkin_INCLUDE_DIRS}&amp;#xd;
)&amp;#xd;
&amp;#xd;
&amp;#xd;
add_executable(list_topics_node src/list_topics_node.cpp)&amp;#xd;
target_link_libraries(list_topics_node ${catkin_LIBRARIES})&amp;#xd;
add_dependencies(list_topics_node list_topics_generate_messages_cpp)&amp;#xd;
)))&amp;#xd;
&amp;#xd;
The required components have been added when the package has been created (see above). At first, catkin has to know that it has to create headerfiles from the service definition. This can be declared in section add_service_files. Further the message-dependencies have to be declared. As a reminder, the service definition is a composition of messages. In this case two standard messages are used. So, In section `generate_messages the entry std_msgs has to be made.&amp;#xd;
After including the catkin directory and adding the executable (see also: example-2-hello-worldcpp), a dependency has to be added, that the service header have to be build before building the executable. Otherwise the build process will throw an error.&amp;#xd;
After editing the CMakeLists.txt file the build process can start:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ catkin_make&amp;#xd;
)))&amp;#xd;
&amp;#xd;
(% class="box" %)&amp;#xd;
(((&amp;#xd;
Note: Usually the manifest package.xml has to be edited as well. But in this case, the required dependencies have been added by using the catkin_create_pkg command with the proper dependencies.&amp;#xd;
)))&amp;#xd;
&amp;#xd;
&amp;#xd;
&amp;#xd;
==== &amp;#xd;
**Using the package** ====&amp;#xd;
&amp;#xd;
The service is quite simple to use. Open up three terminals and start a roscore in the first one. Than start with&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosrun list_topics list_topics_node&amp;#xd;
)))&amp;#xd;
&amp;#xd;
the service-server node.&amp;#xd;
The last step is to call the service. With knowledge from the previous chapter, the command&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice call /show_number_of_topics&amp;#xd;
)))&amp;#xd;
&amp;#xd;
should be familiar.&amp;#xd;
&amp;#xd;
&amp;#xd;
&amp;#xd;
=== &amp;#xd;
Further Examples ===&amp;#xd;
&amp;#xd;
(% class="box" %)&amp;#xd;
(((&amp;#xd;
As said in the introduction, this is designed as rolling release. So, the number of examples and/or other sections will increase in future.&amp;#xd;
)))&amp;#xd;
&amp;#xd;
==== &amp;#xd;
**Spawn a turtle with a service** ====&amp;#xd;
&amp;#xd;
Another good described example can be found in this free-of-charge book in chapter 8.3. In this example the author describes how to implement a node, that calls the service /spawn provided by the node /turtlesim_node. The proceeding is similar to the above one, but it may be a good exersise to implement it on your own.&amp;#xd;
&amp;#xd;
1. Note: Calling(% class="mark" %) $ rosnode info &amp;lt;node-name>(%%) will return the services provided by the node. ROS nodes&amp;#xd;
1. rosrpc stands for ROS-~_~_R~_~_emote ~_~_P~_~_rocedure ~_~_C~_~_all&amp;#xd;
1. The hyphens are not optional, rather part of the syntax.&amp;#xd;
&lt;/content>
  &lt;attachment>
    &lt;filename>ros_service_basic_struture.png&lt;/filename>
    &lt;author>XWiki.DavidDudzik&lt;/author>
    &lt;date>1545220217000&lt;/date>
    &lt;version>1.1&lt;/version>
    &lt;comment/>
    &lt;filesize>8991&lt;/filesize>
  &lt;/attachment>
  &lt;attachment>
    &lt;filename>ros_service_graph.png&lt;/filename>
    &lt;author>XWiki.DavidDudzik&lt;/author>
    &lt;date>1545220848000&lt;/date>
    &lt;version>1.1&lt;/version>
    &lt;comment/>
    &lt;filesize>35423&lt;/filesize>
  &lt;/attachment>
&lt;/xwikidoc>@


8.1
log
@@
text
@d13 3
a15 3
  &lt;date>1545223753000&lt;/date>
  &lt;contentUpdateDate>1545223753000&lt;/contentUpdateDate>
  &lt;version>8.1&lt;/version>
d21 599
a619 619
  &lt;content>== Ros service ==

----

Sitemap

* Ros service
** Call a service from the terminal
** Example 5: Server-Client-Adder
*** srv-Typedefinition
*** Creating the server-node
*** Creating the client-node
*** build-process
*** Using the package
** Example 6: Ask the master
*** Define the service
*** Creating the server
*** Building the service-server
*** Using the package
** Further Examples
*** Spawn a turtle with a service


== 
Ros service ==

----

Until now, the communication between two nodes was based on messages, that where published under topics. This is the best way for a continous informationstream or data-exchange. But when there is asynchronous task to do, then there are far better solutions.
The simplest solution in ROS is called "service". A service relies on a request-response-system. That means, one node is sending an service-request to a second node, that is offering a service. The second node is doing the task and then sends a response to the first node, whether the task has failed or suceeded.


(% style="text-align:center" %)
[[image:ros_service_basic_struture.png||alt="Fig.1: ROS service basic structure"]]

{{{Fig.1: ROS service basic structure}}}

Mostly services are called by nodes, but now and then it is helpful to call service from the terminal. To get an impression how a service works, usually in the background, a service is going to be called by hand.

First, two terminals are necessary. In terminal one a (% class="mark" %)roscore(%%) has to be launched. In the second terminal a node will be started:


(% class="box infomessage" %)
(((
$ rosrun turtlesim turtlesim_node
)))

After this, run the command

(% class="box infomessage" %)
(((
$ rosservice list
)))

in a third terminal.
Executing this command will show an output similar to this:

(% class="box infomessage" %)
(((
$ rosservice list
/clear
/kill
/reset
/rosout/get_loggers
/rosout/set_logger_level
/spawn
/turtle1/set_pen
/turtle1/teleport_absolute
/turtle1/teleport_relative
/turtlesim/get_loggers
/turtlesim/set_logger_level
)))

At first glance, there are some services that are binded to a specific namespace and others that are located in the root namespace. But every service is provided by a node, so at first it is interesting to which node the services in the root namespace belong to.
To find this out, type in the above command extend by the option (% class="mark" %)-n(%%).

(% class="box infomessage" %)
(((
$ rosservice list -n
)))

 The output is almost the same as before, but now every service in the list is extended by the node that provides it1.
To get more detailed information to a service, use

(% class="box infomessage" %)
(((
$ rosservice info &amp;lt;service-name>
)))

 The output for the service /kill is:

(% class="box infomessage" %)
(((
$ rosservice info /kill
   Node: /turtlesim
   URI: rosrpc:~/~/ubuntu-ros:37541
   Type: turtlesim/Kill
   Args: name
)))

The node that provides this service is the node /turtlesim with the URI rosrpc:~/~/ubuntu-ros:375412. The type of the service is (% class="mark" %)turtlesim/kill(%%), that takes the argument(% class="mark" %) name.(%%)
There are a lot of service-types in ROS. Some service-types are basic datatypes, but others are a structure of basic datatypes or complex datatypes nested in each other. So, it can be very difficult to discover all in- and outputs. The command

(% class="box infomessage" %)
(((
$ rossrv show &amp;lt;service-type>
)))

will help to solve this problem.

For the service-type(% class="mark" %) turtlesim/kill(%%) the output is:

(% class="box infomessage" %)
(((
$ rossrv show turtlesim/Kill
   string name
   ~-~--
)))

Everthing above the three hyphens3 are the input arguments. In this case there is just one string input argument (the name of the isntance) and no output (or returning) argument. A service-type can contain all thinkable permutations of in-and output arguments. So, it is also possible to have a service-type with no input argument and no output argument. Sending a request to a node that controls a peripherie object, may be a comprehensible scenario. The node just needs to know that the service is called and the callback-function has to be executed. The callback function will return a bool (true or false). This may be the only required information for the node, that sent the request. 



= 
Call a service from the terminal =

----

In the previous section the structure of ROS service has been discussed. Now, a service will be called with the above setup. The example will be executed with the service (% class="mark" %)/kill(%%). Previously, the command (% class="mark" %)$ rossrv show(%%) was used to get information about the necessary input arguments.
This service expects the name of the turtle, which should be removed. So the command will be something like this:

(% class="box infomessage" %)
(((
$ rosservice call /kill 'turtle1'
)))

 After executing this command, the turtle in the window will disappear. For a better understanding what happend, type in[^trouble_shooting_rqt]:

(% class="box infomessage" %)
(((
$ rqt_graph
)))

(% style="text-align:center" %)
[[image:ros_service_graph.png]]


====== **Fig.2: Output of rqt_graph after calling the service /Spawn** ======

Comparing the above figure with rqt_graph/Fig.1 will show, that the node /turtlesim did not disapper. Only the topic /turtle1/cmd_vel is removed from the graph.
To get a new turtle, without restarting the node, use the service /spawn. This might be a good task to get a bit more familiar to the concept of services in ROS. When getting issues, consulte the book A gentle introduction to ROS[^ros_intro], the usage of the service /spawn is described there very well.


= Example 5: Server-Client-Adder =

----

(% class="box" %)
(((
This example is inspired from the example http:~/~/wiki.ros.org/ROS/Tutorials/WritingServiceClient. The idea is taken from this tutorial, but the implementation and the description may differ in some points.
)))

 In this example, a adder based on a server-client-relation will be created. The idea is to send two integer values from the client to the server. The server calculates the sum of the two integer values and returns the sum to the client.
the first step is to create a new package with the appropriate dependencies. The proper command is:

(% class="box infomessage" %)
(((
$ catkin_create_pkg calculator roscpp std_msgs message_generation
)))

 The new generated package is called calculator. (% class="mark" %)roscpp(%%) is required to use the C++-API and message_generation will be needed for generating the service-headers during the build process[^msg_generation].


====   ====

==== 
**srv-Typedefinition** ====

----

After succesful generation of the new package, the definition of the service is required. First, a new folder has to be created in the diretory of the package.

(% class="box infomessage" %)
(((
$ mkdir -p srv
)))

Then, open a new file with

(% class="box infomessage" %)
(((
$ gedit calc_service.srv
)))

This file will contain the definition of the service. For this example two int64 alues are chosen for the request and also a int64 value for the response. So, enter the following lines in to the editor. 

(% class="box infomessage" %)
(((
int64 a
int64 b
~-~--
int64 sum
)))

(% class="box" %)
(((
Note: The three hyphens are part of the syntax.
)))

 From this file the header will generated during the build-process.



===== 
**Creating the server-node** =====

----

===== The next task is creating the nodes. At first, the server node will be created. This takes the response, does some computation and then passes the result back to the client. The source-code can look like this: =====

(% class="box infomessage" %)
(((
#include "ros/ros.h"
#include "calculator/calc_srv.h"
#include &amp;lt;string>

bool add(calculator::calc_srv::Request  &amp;amp;request, calculator::calc_srv::Response &amp;amp;response){
  response.sum = request.a + request.b;
  ROS_INFO_STREAM("The two integers are: " &amp;lt;&amp;lt; request.a &amp;lt;&amp;lt; " and " &amp;lt;&amp;lt; request.b &amp;lt;&amp;lt; "\n");
  ROS_INFO_STREAM("The calculated sum is " &amp;lt;&amp;lt; response.sum &amp;lt;&amp;lt; "\n");
  return true;
}

int main(int argc, char ~*~*argv)
{  
  ros::init(argc, argv, "server");
  ros::NodeHandle n;

  ros::ServiceServer service = n.advertiseService("calculate", &amp;amp;add);  
  ROS_INFO_STREAM("Server ready.");  
  ros::spin();

  return 0;
}

 
)))

The first two lines include the required header files (% class="mark" %)ros/ros.h (%%)and the new (% class="mark" %)created calculator/calc_srv.h(%%)[^calc_header].
Following this, the function(% class="mark" %) bool add()(%%) is defined and declared. This will be used as a callback-function for the service-object. The function expects a request- and a response-object from the (% class="mark" %)class calculator::calc_srv(%%).
Inside the function, the two integers from the object req are added and passed to res.sum. Following, two info-messages are printed to the terminal telling the user what is going on.
The next step is the main-function. At first, the ROS node is initialized as usual. Then, a service-object is created with a member-function of the nodehandle. In the basic configuration it expects two arguments, a servicename and the callback-function. The servicename is chosen as calculate and the callback-function is the one created above. The info-message in the next line is not required, but it is good to know that the server is started.
(% class="mark" %)ros::spin()(%%) is already known from Example 4: Subcriber.


===== 
**Creating the client-node** =====

After the server-node is created successfully (but not build yet), the client-node follows. This will take the input from the commandline and pass the values to the server. After the computation in the server, the result will be passed back to the client. Then, the client will produce the output in the terminal.
So, the code for this task looks as follows:

(% class="box infomessage" %)
(((
#include "ros/ros.h"
#include "calculator/calc_srv.h"
#include &amp;lt;boost/lexical_cast.hpp>

int main(int argc, char ~*~*argv){    
 
  if (argc != 3)
  {
    ROS_WARN_STREAM("Enter two int_numbers!");
    return 1;
  }

  ros::init(argc, argv, "calc_client");
  ros::NodeHandle n;  
  ros::ServiceClient client = n.serviceClient&amp;lt;calculator::calc_srv>("calculate");  
  calculator::calc_srv srv;

try{
         srv.request.a = boost::lexical_cast&amp;lt;int>(*(argv+1));
           srv.request.b = boost::lexical_cast&amp;lt;int>(*(argv+2));
         }
  catch(const boost::bad_lexical_cast &amp;amp;){
        ROS_ERROR_STREAM("Enter only INTs!");
        return 1;
      }
  
  if (client.call(srv))
  {
      ROS_INFO_STREAM("Result is: " &amp;lt;&amp;lt; srv.response.sum &amp;lt;&amp;lt; "\n");    
  }
  else{
    ROS_ERROR_STREAM("Something went wrong. Bad response from server.");
    return 1; }
  return 0;
}

 
)))


At the top, the library(% class="mark" %) ros/ros.h" (%%)is included as usual, when using the ROS C++-API. (% class="mark" %)calculator/calc_srv.h (%%)provides the informations about the service, which was created in srv-Typedefinition. The boost-library is required for the typecast, later in the code, and the related expection handling.
The main-function starts with a logical-check on the input. (% class="mark" %)argc(%%) contains the number of values entered in the commandline. The if-statement checks for three values, but the server adds only two. On first sight this seems wrong, but the first argument (or better, the zeroth element in the array argv) is always the path where the executable is located. Considering this it is obvious, that the right numbere of argmuents is three.
After this check, the node is created with(% class="mark" %) ros::init()(%%) and(% class="mark" %) ros::NodeHandle(%%). Subsequently the service-client is created in a similiar way as the service-serve. The client-object is initialized by a memberfunction of the nodehandle. At this point it is important to choose the same servicename as the server uses. In this case the right servicename is (% class="mark" %)calculate(%%).


Afterwards an object from (% class="mark" %)calculator::calc_srv(%%) is created. This is required for the next step, where the arguments from the commandline have to be casted from C-string to integer. For this purpose the boost- library provides the (% class="mark" %)lexical_cast&amp;lt;T>()(%%)-function. This function casts the function-argument to the datatype T. If the input can not be casted as expected, the function throws an exception(% class="mark" %) boost::bad_lexical_cast(%%). So, the try-catch-instruction prevents from sending a bad commandline-input to the server.
However, when the commandline-input is correct the following if-statement is executed. In the Argument the call-function is called. The function returns a bool, so it can be used as an argument for the if-statement. If the callback-function add() returns true, the client-node writes the result to the commandline using a logging-message. Otherwise, when the callback-function returns false an error-message is printed in the terminal and the main-function returns with 1.


===== 
**build-process** =====

At this point the two sourcefiles have been created and stored in the src-directory inside the calculator-package. Before the build-process can start the file CMakeLists.txt has to be prepared.
At first open the CMakeLists.txt-file and uncomment the lines


(% class="box infomessage" %)
(((
add_service_files(
    FILES
 )
)))

Now add (% class="mark" %)calc_srv.srv (%%)under FILES. These lines make sure, that the .srv-file in the directory srv is considered during the build-process.

Further, the following lines have to be uncommented.

(% class="box infomessage" %)
(((
 generate_messages(
   DEPENDENCIES
 )
)))

These are required for generating the messages, that are defined inside the service-definition. In this case only standard messagetypes are used, so the only entry will be(% class="mark" %) std_msgs.(%%) This line has to be added under DEPENDENCIES.
The next step is to announce the sourcefiles to the build-process. It is important to remember, that the headerfiles calculator/calc_srv.h, which is included in both sourcefiles is not build yet. That is why it is necessary to add dependencies to the CMakeLists.txt-file. These dependencies make sure, that executables are only then be built, when the build of headerfile has finished.
The generic structure of the dependency-command is:

(% class="box infomessage" %)
(((
add_dependencies(&amp;lt;target> &amp;lt;target_dependency>)
)))

 In this case the proper command is:

(% class="box infomessage" %)
(((
add_dependencies(server calculator_generate_messages_cpp) # for the server
)))

or

(% class="box infomessage" %)
(((
add_dependencies(client calculator_generate_messages_cpp) # for the client
)))

 Maybe it seems a bit strange, that the dependency is related to message_generation and not about service-files. But message_generation works for both[^msg_and_srv]
With the knowledge from Example 2: hello-world.cpp, the following lines can be added to CMakeLists.txt:

(% class="box infomessage" %)
(((
add_executable(server src/server.cpp)
target_link_libraries(server ${catkin_LIBRARIES})
add_dependencies(server calculator_generate_messages_cpp)

add_executable(client src/client.cpp)
target_link_libraries(client ${catkin_LIBRARIES})
add_dependencies(client calculator_generate_messages_cpp)
)))

(% class="box" %)
(((
 Note: The file package.xml has not to be adjusted, because the required dependencies were added when the package was created.
)))

The verylast step is to start the build process. Switch to the top of the workspace and then execute 

(% class="box infomessage" %)
(((
catkin_make
)))


===== 
**Using the package** =====

After a successful build-process two executables are generated. Before they can be used a roscore has to be started. Afterwards, start the server-node with

(% class="box infomessage" %)
(((
$ rosrun calculator server
)))

and the cleint node with 

(% class="box infomessage" %)
(((
$ rosrun calculator client a b
)))

Replace a and b with integer values. For example, execute:

(% class="box infomessage" %)
(((
 $ rosrun calculator client 4 12
)))

This results in the following output in the server-terminal: 

(% class="box infomessage" %)
(((
[ INFO] [1509369925.682593826]: The two integers are: 4 and 12

[ INFO] [1509369925.682726903]: The calculated sum is 16
)))

The output in the client-terminal will be similar to: 

(% class="box infomessage" %)
(((
[ INFO] [1509369925.683124120]: Result is: 16
)))

Invalid inputs like

(% class="box infomessage" %)
(((
$ rosrun calculator client 4 xy
)))

or

(% class="box infomessage" %)
(((
$ rosrun calculator client
)))

will cause error-messages, due to the error-handling in the nodes. 


= Example 6: Ask the master =

----

This is another example for creating a service in a ROS-network. The node provides a service that should return the number of active topics in the ROS network.
At first a new package has to be created. The ROS C++-API is needed for sure and furthermore the standard ROS-messages. So, the command for creating the new package is (of course, this command should be executed in the source-folder of the workspace):

(% class="box infomessage" %)
(((
$ catkin_create_pkg list_topics roscpp std_msgs message_generation
)))

 The new package is called list_topics with the dependencies roscpp, message_generation and std_msgs.


===== 
**Define the service** =====

The next step is a new one. To define a service switch in the package folder and create a new folder called srv. Open this folder an create a new file. This file contains the definition of the service, i.e. the input and output arguments. This file will be named with "list_topics_service.srv".
Then, open the file and type in the definition of the service. The service does not need any input arguments. The output argument, what the service should return, is a single integer value. So, the definition looks like this:

(% class="box infomessage" %)
(((
~-~--
int16 number_of_topics
)))

The definition is to read as follows. Over the three hyphens there are the input argument(s). In this case it is empty, but also when it empty a messagetype will be required. This messagetype is std_msgs/Empty. Under the three hyphens are the output argument(s). As seen above, only one argument is listed. The output argument of this service is an 16bit integer called number_of_topics.
At this point the service is already defined.


===== 
**Creating the server** =====

After defining the service, a server that provides the service is necessary. For this purpsose change to the folder src within the package directory and create a file named "list_topics_node.cpp". The server, which provides the desired service, is created by the following code:

(% class="box infomessage" %)
(((
#include "ros/ros.h"
#include "list_topics/list_topics_service.h"

bool number_topics(list_topics::list_topics_service::Request &amp;amp;req, list_topics::list_topics_service::Response &amp;amp;res){
    ros::master::V_TopicInfo master_topics;
    ros::master::getTopics(master_topics);
    int number_t = master_topics.size();
    ROS_INFO("Topics: [%i]", (int) number_t);
    res.number = number_t;
  return true;
}

int main(int argc, char ~*~*argv)
{  
  ros::init(argc, argv, "list_topics_node");
  ros::NodeHandle handle;
 
  ros::ServiceServer service = handle.advertiseService("show_number_of_topics", &amp;amp;number_topics);
  ROS_INFO("Returning number of active topics.");
  ros::spin();

  return 0;
}
)))

At the very top, the requiered libraries are included. ros/ros.h is necessary every time when the ROS C++-API should be used. The header list_topics/list_topics_service.h includes the service-definition. That there is no such headerfile build so far should be kept in mind for the later build-process.
Further down, the callback-function, that will be executed when the service is called, is defined. The returntype is always bool. It does not matter, whether it is a function or a member function or anything else.
The body of the callback-function contains the
instructions, that will be executed when a new request arrives. At the beginning a new vectorobject from the struct V_TopicInfo is created. In the next line the function getTopics (V_TopicInfo &amp;amp;topics) writes all active topics to the vectorobject by reference. Because V_TopicInfo is just a vector of structs, the member function can be used here to return the size of the vector, which is equal to the number of active topics.
The last instruction in the callback-function is the return argument.
The main-function starts as usual with the initialization of the node. Afterwards the serive_serve is created. The ROS C++-API recommends to do this with the member function of the nodehandle.


(% class="box" %)
(((
A ServiceServer should always be created through a call to NodeHandle::advertiseService(), or copied from one that was. Once all copies of a specific ServiceServer go out of scope, the service associated with it will be unadvertised and the service callback will stop being called. (see: ros::ServiceServer Class Reference)
)))

There are several ways to implement a service. For this introductory example, the simplest option is to use a simple callback function. Only the service name and the name of the callback functions is expected.
Following, an info message that the service server is ready and the instruction to pass control to the node.
Now the node is almost ready to get build with catkin.


===== 
**Building the service-server** =====

Before the node can be build, the file CMakeLists.txt has to be adjusted.

(% class="box infomessage" %)
(((
cmake_minimum_required(VERSION 2.8.3)
project(list_topics)

find_package(catkin REQUIRED COMPONENTS
  message_generation
  roscpp
  std_msgs
)

add_service_files(
    FILES
      list_topics_service.srv
                )


 generate_messages(
   DEPENDENCIES
   std_msgs
                )

include_directories(
  ${catkin_INCLUDE_DIRS}
)


add_executable(list_topics_node src/list_topics_node.cpp)
target_link_libraries(list_topics_node ${catkin_LIBRARIES})
add_dependencies(list_topics_node list_topics_generate_messages_cpp)
)))

The required components have been added when the package has been created (see above). At first, catkin has to know that it has to create headerfiles from the service definition. This can be declared in section add_service_files. Further the message-dependencies have to be declared. As a reminder, the service definition is a composition of messages. In this case two standard messages are used. So, In section `generate_messages the entry std_msgs has to be made.
After including the catkin directory and adding the executable (see also: example-2-hello-worldcpp), a dependency has to be added, that the service header have to be build before building the executable. Otherwise the build process will throw an error.
After editing the CMakeLists.txt file the build process can start:

(% class="box infomessage" %)
(((
$ catkin_make
)))

(% class="box" %)
(((
Note: Usually the manifest package.xml has to be edited as well. But in this case, the required dependencies have been added by using the catkin_create_pkg command with the proper dependencies.
)))



===== 
**Using the package** =====

The service is quite simple to use. Open up three terminals and start a roscore in the first one. Than start with

(% class="box infomessage" %)
(((
$ rosrun list_topics list_topics_node
)))

the service-server node.
The last step is to call the service. With knowledge from the previous chapter, the command

(% class="box infomessage" %)
(((
$ rosservice call /show_number_of_topics
)))

should be familiar.



= 
Further Examples =

(% class="box" %)
(((
As said in the introduction, this is designed as rolling release. So, the number of examples and/or other sections will increase in future.
)))

===== 
**Spawn a turtle with a service** =====

Another good described example can be found in this free-of-charge book in chapter 8.3. In this example the author describes how to implement a node, that calls the service /spawn provided by the node /turtlesim_node. The proceeding is similar to the above one, but it may be a good exersise to implement it on your own.

1. Note: Calling(% class="mark" %) $ rosnode info &amp;lt;node-name>(%%) will return the services provided by the node. ROS nodes
1. rosrpc stands for ROS-~_~_R~_~_emote ~_~_P~_~_rocedure ~_~_C~_~_all
1. The hyphens are not optional, rather part of the syntax.


 &lt;/content>
@


7.2
log
@@
text
@d13 3
a15 3
  &lt;date>1545223316000&lt;/date>
  &lt;contentUpdateDate>1545223316000&lt;/contentUpdateDate>
  &lt;version>7.2&lt;/version>
d18 1
a18 1
  &lt;minorEdit>true&lt;/minorEdit>
d197 1
a197 1
srv-Typedefinition ====
d235 1
a235 1
Creating the server-node =====
d277 1
a277 1
Creating the client-node =====
d334 1
a334 1
build-process =====
d409 1
a409 1
Using the package =====
d481 1
a481 1
Define the service =====
d486 5
d492 2
d495 144
@


7.1
log
@@
text
@d13 3
a15 3
  &lt;date>1545222432000&lt;/date>
  &lt;contentUpdateDate>1545222432000&lt;/contentUpdateDate>
  &lt;version>7.1&lt;/version>
d18 1
a18 1
  &lt;minorEdit>false&lt;/minorEdit>
a43 1

d289 1
a289 1
  
d309 1
a309 1
   
d379 110
a488 1
)))&lt;/content>
@


6.1
log
@@
text
@d13 3
a15 3
  &lt;date>1545222189000&lt;/date>
  &lt;contentUpdateDate>1545222189000&lt;/contentUpdateDate>
  &lt;version>6.1&lt;/version>
a44 1

d271 1
a271 1
Following this, the function(% class="mark" %) bool add()(%%) is defined and declared. This will be used as a callback-function for the service-object. The function expects a request- and a response-object from the (% class="mark" %)class calculator::calc_srv(%%).
d290 1
a290 1
   
d310 1
a310 1
    
d325 1
a325 1
At the top, the library(% class="mark" %) ros/ros.h" (%%)is included as usual, when using the ROS C++-API. (% class="mark" %)calculator/calc_srv.h (%%)provides the informations about the service, which was created in srv-Typedefinition. The boost-library is required for the typecast, later in the code, and the related expection handling.
d327 1
a327 1
After this check, the node is created with(% class="mark" %) ros::init()(%%) and(% class="mark" %) ros::NodeHandle(%%). Subsequently the service-client is created in a similiar way as the service-serve. The client-object is initialized by a memberfunction of the nodehandle. At this point it is important to choose the same servicename as the server uses. In this case the right servicename is (% class="mark" %)calculate(%%).
d330 1
a330 1
Afterwards an object from (% class="mark" %)calculator::calc_srv(%%) is created. This is required for the next step, where the arguments from the commandline have to be casted from C-string to integer. For this purpose the boost- library provides the (% class="mark" %)lexical_cast&amp;lt;T>()(%%)-function. This function casts the function-argument to the datatype T. If the input can not be casted as expected, the function throws an exception(% class="mark" %) boost::bad_lexical_cast(%%). So, the try-catch-instruction prevents from sending a bad commandline-input to the server.
d359 1
a359 1
These are required for generating the messages, that are defined inside the service-definition. In this case only standard messagetypes are used, so the only entry will be(% class="mark" %) std_msgs.(%%) This line has to be added under DEPENDENCIES.
d361 20
a380 1
The generic structure of the dependency-command is:&lt;/content>
@


5.1
log
@@
text
@&lt;?xml version='1.1' encoding='UTF-8'?>
&lt;xwikidoc version="1.3" reference="Projects.MoRoP.ROS GettingStarted.ROS service.WebHome" locale="">
  &lt;web>Projects.MoRoP.ROS GettingStarted.ROS service&lt;/web>
  &lt;name>WebHome&lt;/name>
  &lt;language/>
  &lt;defaultLanguage>en&lt;/defaultLanguage>
  &lt;translation>0&lt;/translation>
  &lt;creator>XWiki.DavidDudzik&lt;/creator>
  &lt;creationDate>1545220035000&lt;/creationDate>
  &lt;parent>Projects.MoRoP.ROS GettingStarted.WebHome&lt;/parent>
  &lt;author>XWiki.DavidDudzik&lt;/author>
  &lt;contentAuthor>XWiki.DavidDudzik&lt;/contentAuthor>
  &lt;date>1545221639000&lt;/date>
  &lt;contentUpdateDate>1545221639000&lt;/contentUpdateDate>
  &lt;version>5.1&lt;/version>
  &lt;title>ROS service&lt;/title>
  &lt;comment/>
  &lt;minorEdit>false&lt;/minorEdit>
  &lt;syntaxId>xwiki/2.1&lt;/syntaxId>
  &lt;hidden>false&lt;/hidden>
  &lt;content>== Ros service ==&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
Sitemap&amp;#xd;
&amp;#xd;
* Ros service&amp;#xd;
&amp;#xd;
&amp;#xd;
** Call a service from the terminal&amp;#xd;
** Example 5: Server-Client-Adder&amp;#xd;
*** srv-Typedefinition&amp;#xd;
*** Creating the server-node&amp;#xd;
*** Creating the client-node&amp;#xd;
*** build-process&amp;#xd;
*** Using the package&amp;#xd;
&amp;#xd;
&amp;#xd;
** Example 6: Ask the master&amp;#xd;
*** Define the service&amp;#xd;
*** Creating the server&amp;#xd;
*** Building the service-server&amp;#xd;
*** Using the package&amp;#xd;
&amp;#xd;
&amp;#xd;
** Further Examples&amp;#xd;
*** Spawn a turtle with a service&amp;#xd;
&amp;#xd;
&amp;#xd;
&amp;#xd;
&amp;#xd;
&amp;#xd;
&amp;#xd;
== &amp;#xd;
Ros service ==&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
Until now, the communication between two nodes was based on messages, that where published under topics. This is the best way for a continous informationstream or data-exchange. But when there is asynchronous task to do, then there are far better solutions.&amp;#xd;
The simplest solution in ROS is called "service". A service relies on a request-response-system. That means, one node is sending an service-request to a second node, that is offering a service. The second node is doing the task and then sends a response to the first node, whether the task has failed or suceeded.&amp;#xd;
&amp;#xd;
&amp;#xd;
(% style="text-align:center" %)&amp;#xd;
[[image:ros_service_basic_struture.png||alt="Fig.1: ROS service basic structure"]]&amp;#xd;
&amp;#xd;
{{{Fig.1: ROS service basic structure}}}&amp;#xd;
&amp;#xd;
Mostly services are called by nodes, but now and then it is helpful to call service from the terminal. To get an impression how a service works, usually in the background, a service is going to be called by hand.&amp;#xd;
&amp;#xd;
First, two terminals are necessary. In terminal one a (% class="mark" %)roscore(%%) has to be launched. In the second terminal a node will be started:&amp;#xd;
&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosrun turtlesim turtlesim_node&amp;#xd;
)))&amp;#xd;
&amp;#xd;
After this, run the command&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice list&amp;#xd;
)))&amp;#xd;
&amp;#xd;
in a third terminal.&amp;#xd;
Executing this command will show an output similar to this:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice list&amp;#xd;
/clear&amp;#xd;
/kill&amp;#xd;
/reset&amp;#xd;
/rosout/get_loggers&amp;#xd;
/rosout/set_logger_level&amp;#xd;
/spawn&amp;#xd;
/turtle1/set_pen&amp;#xd;
/turtle1/teleport_absolute&amp;#xd;
/turtle1/teleport_relative&amp;#xd;
/turtlesim/get_loggers&amp;#xd;
/turtlesim/set_logger_level&amp;#xd;
)))&amp;#xd;
&amp;#xd;
At first glance, there are some services that are binded to a specific namespace and others that are located in the root namespace. But every service is provided by a node, so at first it is interesting to which node the services in the root namespace belong to.&amp;#xd;
To find this out, type in the above command extend by the option (% class="mark" %)-n(%%).&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice list -n&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 The output is almost the same as before, but now every service in the list is extended by the node that provides it1.&amp;#xd;
To get more detailed information to a service, use&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice info &amp;lt;service-name>&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 The output for the service /kill is:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice info /kill&amp;#xd;
   Node: /turtlesim&amp;#xd;
   URI: rosrpc:~/~/ubuntu-ros:37541&amp;#xd;
   Type: turtlesim/Kill&amp;#xd;
   Args: name&amp;#xd;
)))&amp;#xd;
&amp;#xd;
The node that provides this service is the node /turtlesim with the URI rosrpc:~/~/ubuntu-ros:375412. The type of the service is (% class="mark" %)turtlesim/kill(%%), that takes the argument(% class="mark" %) name.(%%)&amp;#xd;
There are a lot of service-types in ROS. Some service-types are basic datatypes, but others are a structure of basic datatypes or complex datatypes nested in each other. So, it can be very difficult to discover all in- and outputs. The command&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rossrv show &amp;lt;service-type>&amp;#xd;
)))&amp;#xd;
&amp;#xd;
will help to solve this problem.&amp;#xd;
&amp;#xd;
For the service-type(% class="mark" %) turtlesim/kill(%%) the output is:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rossrv show turtlesim/Kill&amp;#xd;
   string name&amp;#xd;
   ~-~--&amp;#xd;
)))&amp;#xd;
&amp;#xd;
Everthing above the three hyphens3 are the input arguments. In this case there is just one string input argument (the name of the isntance) and no output (or returning) argument. A service-type can contain all thinkable permutations of in-and output arguments. So, it is also possible to have a service-type with no input argument and no output argument. Sending a request to a node that controls a peripherie object, may be a comprehensible scenario. The node just needs to know that the service is called and the callback-function has to be executed. The callback function will return a bool (true or false). This may be the only required information for the node, that sent the request. &amp;#xd;
&amp;#xd;
&amp;#xd;
&amp;#xd;
= &amp;#xd;
Call a service from the terminal =&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
In the previous section the structure of ROS service has been discussed. Now, a service will be called with the above setup. The example will be executed with the service (% class="mark" %)/kill(%%). Previously, the command (% class="mark" %)$ rossrv show(%%) was used to get information about the necessary input arguments.&amp;#xd;
This service expects the name of the turtle, which should be removed. So the command will be something like this:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rosservice call /kill 'turtle1'&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 After executing this command, the turtle in the window will disappear. For a better understanding what happend, type in[^trouble_shooting_rqt]:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ rqt_graph&amp;#xd;
)))&amp;#xd;
&amp;#xd;
(% style="text-align:center" %)&amp;#xd;
[[image:ros_service_graph.png]]&amp;#xd;
&amp;#xd;
&amp;#xd;
====== **Fig.2: Output of rqt_graph after calling the service /Spawn** ======&amp;#xd;
&amp;#xd;
Comparing the above figure with rqt_graph/Fig.1 will show, that the node /turtlesim did not disapper. Only the topic /turtle1/cmd_vel is removed from the graph.&amp;#xd;
To get a new turtle, without restarting the node, use the service /spawn. This might be a good task to get a bit more familiar to the concept of services in ROS. When getting issues, consulte the book A gentle introduction to ROS[^ros_intro], the usage of the service /spawn is described there very well.&amp;#xd;
&amp;#xd;
&amp;#xd;
= Example 5: Server-Client-Adder =&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
(% class="box" %)&amp;#xd;
(((&amp;#xd;
This example is inspired from the example http:~/~/wiki.ros.org/ROS/Tutorials/WritingServiceClient. The idea is taken from this tutorial, but the implementation and the description may differ in some points.&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 In this example, a adder based on a server-client-relation will be created. The idea is to send two integer values from the client to the server. The server calculates the sum of the two integer values and returns the sum to the client.&amp;#xd;
the first step is to create a new package with the appropriate dependencies. The proper command is:&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ catkin_create_pkg calculator roscpp std_msgs message_generation&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 The new generated package is called calculator. (% class="mark" %)roscpp(%%) is required to use the C++-API and message_generation will be needed for generating the service-headers during the build process[^msg_generation].&amp;#xd;
&amp;#xd;
&amp;#xd;
====   ====&amp;#xd;
&amp;#xd;
==== &amp;#xd;
srv-Typedefinition ====&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
After succesful generation of the new package, the definition of the service is required. First, a new folder has to be created in the diretory of the package.&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ mkdir -p srv&amp;#xd;
)))&amp;#xd;
&amp;#xd;
Then, open a new file with&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
$ gedit calc_service.srv&amp;#xd;
)))&amp;#xd;
&amp;#xd;
This file will contain the definition of the service. For this example two int64 alues are chosen for the request and also a int64 value for the response. So, enter the following lines in to the editor. &amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
int64 a&amp;#xd;
int64 b&amp;#xd;
~-~--&amp;#xd;
int64 sum&amp;#xd;
)))&amp;#xd;
&amp;#xd;
(% class="box" %)&amp;#xd;
(((&amp;#xd;
Note: The three hyphens are part of the syntax.&amp;#xd;
)))&amp;#xd;
&amp;#xd;
 From this file the header will generated during the build-process.&amp;#xd;
&amp;#xd;
&amp;#xd;
&amp;#xd;
===== &amp;#xd;
Creating the server-node =====&amp;#xd;
&amp;#xd;
----&amp;#xd;
&amp;#xd;
===== The next task is creating the nodes. At first, the server node will be created. This takes the response, does some computation and then passes the result back to the client. The source-code can look like this: =====&amp;#xd;
&amp;#xd;
(% class="box infomessage" %)&amp;#xd;
(((&amp;#xd;
#include "ros/ros.h"&amp;#xd;
#include "calculator/calc_srv.h"&amp;#xd;
#include &amp;lt;string>&amp;#xd;
&amp;#xd;
bool add(calculator::calc_srv::Request  &amp;amp;request, calculator::calc_srv::Response &amp;amp;response){&amp;#xd;
  response.sum = request.a + request.b;&amp;#xd;
  ROS_INFO_STREAM("The two integers are: " &amp;lt;&amp;lt; request.a &amp;lt;&amp;lt; " and " &amp;lt;&amp;lt; request.b &amp;lt;&amp;lt; "\n");&amp;#xd;
  ROS_INFO_STREAM("The calculated sum is " &amp;lt;&amp;lt; response.sum &amp;lt;&amp;lt; "\n");&amp;#xd;
  return true;&amp;#xd;
}&amp;#xd;
&amp;#xd;
int main(int argc, char ~*~*argv)&amp;#xd;
{  &amp;#xd;
  ros::init(argc, argv, "server");&amp;#xd;
  ros::NodeHandle n;&amp;#xd;
&amp;#xd;
  ros::ServiceServer service = n.advertiseService("calculate", &amp;amp;add);  &amp;#xd;
  ROS_INFO_STREAM("Server ready.");  &amp;#xd;
  ros::spin();&amp;#xd;
&amp;#xd;
  return 0;&amp;#xd;
}&amp;#xd;
&amp;#xd;
 &amp;#xd;
)))&amp;#xd;
&amp;#xd;
The first two lines include the required header files ros/ros.hand the new created calculator/calc_srv.h[^calc_header].&amp;#xd;
Following this, the function bool add() is defined and declared. This will be used as a callback-function for the service-object. The function expects a request- and a response-object from the class calculator::calc_srv.&amp;#xd;
Inside the function, the two integers from the object req are added and passed to res.sum. Following, two info-messages are printed to the terminal telling the user what is going on.&amp;#xd;
The next step is the main-function. At first, the ROS node is initialized as usual. Then, a service-object is created with a member-function of the nodehandle. In the basic configuration it expects two arguments, a servicename and the callback-function. The servicename is chosen as calculate and the callback-function is the one created above. The info-message in the next line is not required, but it is good to know that the server is started.&amp;#xd;
ros::spin() is already known from Example 4: Subcriber.&amp;#xd;
&amp;#xd;
&amp;#xd;
 &lt;/content>
  &lt;attachment>
    &lt;filename>ros_service_basic_struture.png&lt;/filename>
    &lt;author>XWiki.DavidDudzik&lt;/author>
    &lt;date>1545220217000&lt;/date>
    &lt;version>1.1&lt;/version>
    &lt;comment/>
    &lt;filesize>8991&lt;/filesize>
  &lt;/attachment>
  &lt;attachment>
    &lt;filename>ros_service_graph.png&lt;/filename>
    &lt;author>XWiki.DavidDudzik&lt;/author>
    &lt;date>1545220848000&lt;/date>
    &lt;version>1.1&lt;/version>
    &lt;comment/>
    &lt;filesize>35423&lt;/filesize>
  &lt;/attachment>
&lt;/xwikidoc>@


4.1
log
@@
text
@d13 3
a15 3
  &lt;date>1545221330000&lt;/date>
  &lt;contentUpdateDate>1545221330000&lt;/contentUpdateDate>
  &lt;version>4.1&lt;/version>
d21 265
a285 241
  &lt;content>== Ros service ==

----

Sitemap






== 
Ros service ==

----

Until now, the communication between two nodes was based on messages, that where published under topics. This is the best way for a continous informationstream or data-exchange. But when there is asynchronous task to do, then there are far better solutions.
The simplest solution in ROS is called "service". A service relies on a request-response-system. That means, one node is sending an service-request to a second node, that is offering a service. The second node is doing the task and then sends a response to the first node, whether the task has failed or suceeded.


[[image:ros_service_basic_struture.png||alt="Fig.1: ROS service basic structure"]]

{{{Fig.1: ROS service basic structure}}}

Mostly services are called by nodes, but now and then it is helpful to call service from the terminal. To get an impression how a service works, usually in the background, a service is going to be called by hand.

First, two terminals are necessary. In terminal one a (% class="mark" %)roscore(%%) has to be launched. In the second terminal a node will be started:


(% class="box infomessage" %)
(((
$ rosrun turtlesim turtlesim_node
)))

After this, run the command

(% class="box infomessage" %)
(((
$ rosservice list
)))

in a third terminal.
Executing this command will show an output similar to this:

(% class="box infomessage" %)
(((
$ rosservice list
/clear
/kill
/reset
/rosout/get_loggers
/rosout/set_logger_level
/spawn
/turtle1/set_pen
/turtle1/teleport_absolute
/turtle1/teleport_relative
/turtlesim/get_loggers
/turtlesim/set_logger_level
)))

At first glance, there are some services that are binded to a specific namespace and others that are located in the root namespace. But every service is provided by a node, so at first it is interesting to which node the services in the root namespace belong to.
To find this out, type in the above command extend by the option (% class="mark" %)-n(%%).

(% class="box infomessage" %)
(((
$ rosservice list -n
)))

 The output is almost the same as before, but now every service in the list is extended by the node that provides it1.
To get more detailed information to a service, use

(% class="box infomessage" %)
(((
$ rosservice info &amp;lt;service-name>
)))

 The output for the service /kill is:

(% class="box infomessage" %)
(((
$ rosservice info /kill
   Node: /turtlesim
   URI: rosrpc:~/~/ubuntu-ros:37541
   Type: turtlesim/Kill
   Args: name
)))

The node that provides this service is the node /turtlesim with the URI rosrpc:~/~/ubuntu-ros:375412. The type of the service is (% class="mark" %)turtlesim/kill(%%), that takes the argument(% class="mark" %) name.(%%)
There are a lot of service-types in ROS. Some service-types are basic datatypes, but others are a structure of basic datatypes or complex datatypes nested in each other. So, it can be very difficult to discover all in- and outputs. The command

(% class="box infomessage" %)
(((
$ rossrv show &amp;lt;service-type>
)))

will help to solve this problem.

For the service-type(% class="mark" %) turtlesim/kill(%%) the output is:

(% class="box infomessage" %)
(((
$ rossrv show turtlesim/Kill
   string name
   ~-~--
)))

Everthing above the three hyphens3 are the input arguments. In this case there is just one string input argument (the name of the isntance) and no output (or returning) argument. A service-type can contain all thinkable permutations of in-and output arguments. So, it is also possible to have a service-type with no input argument and no output argument. Sending a request to a node that controls a peripherie object, may be a comprehensible scenario. The node just needs to know that the service is called and the callback-function has to be executed. The callback function will return a bool (true or false). This may be the only required information for the node, that sent the request. 



= 
Call a service from the terminal =

----

In the previous section the structure of ROS service has been discussed. Now, a service will be called with the above setup. The example will be executed with the service (% class="mark" %)/kill(%%). Previously, the command (% class="mark" %)$ rossrv show(%%) was used to get information about the necessary input arguments.
This service expects the name of the turtle, which should be removed. So the command will be something like this:

(% class="box infomessage" %)
(((
$ rosservice call /kill 'turtle1'
)))

 After executing this command, the turtle in the window will disappear. For a better understanding what happend, type in[^trouble_shooting_rqt]:

(% class="box infomessage" %)
(((
$ rqt_graph
)))

 [[image:ros_service_graph.png]]


====== **Fig.2: Output of rqt_graph after calling the service /Spawn** ======

Comparing the above figure with rqt_graph/Fig.1 will show, that the node /turtlesim did not disapper. Only the topic /turtle1/cmd_vel is removed from the graph.
To get a new turtle, without restarting the node, use the service /spawn. This might be a good task to get a bit more familiar to the concept of services in ROS. When getting issues, consulte the book A gentle introduction to ROS[^ros_intro], the usage of the service /spawn is described there very well.


= Example 5: Server-Client-Adder =

----

(% class="box" %)
(((
This example is inspired from the example http:~/~/wiki.ros.org/ROS/Tutorials/WritingServiceClient. The idea is taken from this tutorial, but the implementation and the description may differ in some points.
)))

 In this example, a adder based on a server-client-relation will be created. The idea is to send two integer values from the client to the server. The server calculates the sum of the two integer values and returns the sum to the client.
the first step is to create a new package with the appropriate dependencies. The proper command is:

(% class="box infomessage" %)
(((
$ catkin_create_pkg calculator roscpp std_msgs message_generation
)))

 The new generated package is called calculator. (% class="mark" %)roscpp(%%) is required to use the C++-API and message_generation will be needed for generating the service-headers during the build process[^msg_generation].


====   ====

==== 
srv-Typedefinition ====

----

After succesful generation of the new package, the definition of the service is required. First, a new folder has to be created in the diretory of the package.

(% class="box infomessage" %)
(((
$ mkdir -p srv
)))

Then, open a new file with

(% class="box infomessage" %)
(((
$ gedit calc_service.srv
)))

This file will contain the definition of the service. For this example two int64 alues are chosen for the request and also a int64 value for the response. So, enter the following lines in to the editor. 

(% class="box infomessage" %)
(((
int64 a
int64 b
~-~--
int64 sum
)))

(% class="box" %)
(((
Note: The three hyphens are part of the syntax.
)))

 From this file the header will generated during the build-process.



===== 
Creating the server-node =====

----

===== The next task is creating the nodes. At first, the server node will be created. This takes the response, does some computation and then passes the result back to the client. The source-code can look like this: =====

(% class="box infomessage" %)
(((
#include "ros/ros.h"
#include "calculator/calc_srv.h"
#include &amp;lt;string>

bool add(calculator::calc_srv::Request  &amp;amp;request, calculator::calc_srv::Response &amp;amp;response){
  response.sum = request.a + request.b;
  ROS_INFO_STREAM("The two integers are: " &amp;lt;&amp;lt; request.a &amp;lt;&amp;lt; " and " &amp;lt;&amp;lt; request.b &amp;lt;&amp;lt; "\n");
  ROS_INFO_STREAM("The calculated sum is " &amp;lt;&amp;lt; response.sum &amp;lt;&amp;lt; "\n");
  return true;
}

int main(int argc, char ~*~*argv)
{  
  ros::init(argc, argv, "server");
  ros::NodeHandle n;

  ros::ServiceServer service = n.advertiseService("calculate", &amp;amp;add);  
  ROS_INFO_STREAM("Server ready.");  
  ros::spin();

  return 0;
}

 
)))

The first two lines include the required header files ros/ros.hand the new created calculator/calc_srv.h[^calc_header].
Following this, the function bool add() is defined and declared. This will be used as a callback-function for the service-object. The function expects a request- and a response-object from the class calculator::calc_srv.
Inside the function, the two integers from the object req are added and passed to res.sum. Following, two info-messages are printed to the terminal telling the user what is going on.
The next step is the main-function. At first, the ROS node is initialized as usual. Then, a service-object is created with a member-function of the nodehandle. In the basic configuration it expects two arguments, a servicename and the callback-function. The servicename is chosen as calculate and the callback-function is the one created above. The info-message in the next line is not required, but it is good to know that the server is started.
ros::spin() is already known from Example 4: Subcriber.


@


3.1
log
@Uploaded new attachment "ros_service_graph.png", version {1}
@
text
@d13 3
a15 3
  &lt;date>1545220848000&lt;/date>
  &lt;contentUpdateDate>1545220035000&lt;/contentUpdateDate>
  &lt;version>3.1&lt;/version>
d17 1
a17 1
  &lt;comment>Uploaded new attachment "ros_service_graph.png", version {1}&lt;/comment>
d41 1
d43 219
@


2.1
log
@Uploaded new attachment "ros_service_basic_struture.png", version {1}
@
text
@d13 1
a13 1
  &lt;date>1545220218000&lt;/date>
d15 1
a15 1
  &lt;version>2.1&lt;/version>
d17 1
a17 1
  &lt;comment>Uploaded new attachment "ros_service_basic_struture.png", version {1}&lt;/comment>
d51 8
@


1.1
log
@@
text
@d13 1
a13 1
  &lt;date>1545220035000&lt;/date>
d15 1
a15 1
  &lt;version>1.1&lt;/version>
d17 1
a17 1
  &lt;comment/>
d43 8
@
</versions>
  <parent>Projects.MoRoP.ROS GettingStarted.WebHome</parent>
  <author>XWiki.DavidDudzik</author>
  <contentAuthor>XWiki.DavidDudzik</contentAuthor>
  <date>1550742478000</date>
  <contentUpdateDate>1550742350000</contentUpdateDate>
  <version>13.1</version>
  <title>ROS service</title>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>false</hidden>
  <content>**Sitemap**

----


{{toc start="2"/}}





== Ros service ==

----

Until now, the communication between two nodes was based on messages, that where published under topics. This is the best way for a continous informationstream or data-exchange. But when there is asynchronous task to do, then there are far better solutions.
The simplest solution in ROS is called "service". A service relies on a request-response-system. That means, one node is sending an service-request to a second node, that is offering a service. The second node is doing the task and then sends a response to the first node, whether the task has failed or suceeded.


(% style="text-align:center" %)
[[image:ros_service_basic_struture.png||alt="Fig.1: ROS service basic structure"]]

{{{Fig.1: ROS service basic structure}}}

Mostly services are called by nodes, but now and then it is helpful to call service from the terminal. To get an impression how a service works, usually in the background, a service is going to be called by hand.

First, two terminals are necessary. In terminal one a (% class="mark" %)roscore(%%) has to be launched. In the second terminal a node will be started:


(% class="box infomessage" %)
(((
$ rosrun turtlesim turtlesim_node
)))

After this, run the command

(% class="box infomessage" %)
(((
$ rosservice list
)))

in a third terminal.
Executing this command will show an output similar to this:

(% class="box infomessage" %)
(((
$ rosservice list
/clear
/kill
/reset
/rosout/get_loggers
/rosout/set_logger_level
/spawn
/turtle1/set_pen
/turtle1/teleport_absolute
/turtle1/teleport_relative
/turtlesim/get_loggers
/turtlesim/set_logger_level
)))

At first glance, there are some services that are binded to a specific namespace and others that are located in the root namespace. But every service is provided by a node, so at first it is interesting to which node the services in the root namespace belong to.
To find this out, type in the above command extend by the option (% class="mark" %)-n(%%).

(% class="box infomessage" %)
(((
$ rosservice list -n
)))

 The output is almost the same as before, but now every service in the list is extended by the node that provides it1.
To get more detailed information to a service, use

(% class="box infomessage" %)
(((
$ rosservice info &lt;service-name>
)))

 The output for the service /kill is:

(% class="box infomessage" %)
(((
$ rosservice info /kill
   Node: /turtlesim
   URI: rosrpc:~/~/ubuntu-ros:37541
   Type: turtlesim/Kill
   Args: name
)))

The node that provides this service is the node /turtlesim with the URI rosrpc:~/~/ubuntu-ros:375412. The type of the service is (% class="mark" %)turtlesim/kill(%%), that takes the argument(% class="mark" %) name.(%%)
There are a lot of service-types in ROS. Some service-types are basic datatypes, but others are a structure of basic datatypes or complex datatypes nested in each other. So, it can be very difficult to discover all in- and outputs. The command

(% class="box infomessage" %)
(((
$ rossrv show &lt;service-type>
)))

will help to solve this problem.

For the service-type(% class="mark" %) turtlesim/kill(%%) the output is:

(% class="box infomessage" %)
(((
$ rossrv show turtlesim/Kill
   string name
   ~-~--
)))

Everthing above the three hyphens3 are the input arguments. In this case there is just one string input argument (the name of the isntance) and no output (or returning) argument. A service-type can contain all thinkable permutations of in-and output arguments. So, it is also possible to have a service-type with no input argument and no output argument. Sending a request to a node that controls a peripherie object, may be a comprehensible scenario. The node just needs to know that the service is called and the callback-function has to be executed. The callback function will return a bool (true or false). This may be the only required information for the node, that sent the request. 



=== Call a service from the terminal ===

----

In the previous section the structure of ROS service has been discussed. Now, a service will be called with the above setup. The example will be executed with the service (% class="mark" %)/kill(%%). Previously, the command (% class="mark" %)$ rossrv show(%%) was used to get information about the necessary input arguments.
This service expects the name of the turtle, which should be removed. So the command will be something like this:

(% class="box infomessage" %)
(((
$ rosservice call /kill 'turtle1'
)))

 After executing this command, the turtle in the window will disappear. For a better understanding what happend, type in[^trouble_shooting_rqt]:

(% class="box infomessage" %)
(((
$ rqt_graph
)))

(% style="text-align:center" %)
[[image:ros_service_graph.png]]


(% class="wikigeneratedid" id="HFig.2:Outputofrqt_graphaftercallingtheservice2FSpawn" %)
(((
**Fig.2: Output of rqt_graph after calling the service /Spawn**
)))

Comparing the above figure with rqt_graph/Fig.1 will show, that the node /turtlesim did not disapper. Only the topic /turtle1/cmd_vel is removed from the graph.
To get a new turtle, without restarting the node, use the service /spawn. This might be a good task to get a bit more familiar to the concept of services in ROS. When getting issues, consulte the book A gentle introduction to ROS[^ros_intro], the usage of the service /spawn is described there very well.


=== Example 5: Server-Client-Adder ===

----

(% class="box" %)
(((
This example is inspired from the example http:~/~/wiki.ros.org/ROS/Tutorials/WritingServiceClient. The idea is taken from this tutorial, but the implementation and the description may differ in some points.
)))

 In this example, a adder based on a server-client-relation will be created. The idea is to send two integer values from the client to the server. The server calculates the sum of the two integer values and returns the sum to the client.
the first step is to create a new package with the appropriate dependencies. The proper command is:

(% class="box infomessage" %)
(((
$ catkin_create_pkg calculator roscpp std_msgs message_generation
)))

 The new generated package is called calculator. (% class="mark" %)roscpp(%%) is required to use the C++-API and message_generation will be needed for generating the service-headers during the build process[^msg_generation].


==== **srv-Typedefinition** ====

----

After succesful generation of the new package, the definition of the service is required. First, a new folder has to be created in the diretory of the package.

(% class="box infomessage" %)
(((
$ mkdir -p srv
)))

Then, open a new file with

(% class="box infomessage" %)
(((
$ gedit calc_service.srv
)))

This file will contain the definition of the service. For this example two int64 alues are chosen for the request and also a int64 value for the response. So, enter the following lines in to the editor. 

(% class="box infomessage" %)
(((
int64 a
int64 b
~-~--
int64 sum
)))

(% class="box" %)
(((
Note: The three hyphens are part of the syntax.
)))

 From this file the header will generated during the build-process.



==== **Creating the server-node** ====

----

(% class="wikigeneratedid" id="HThenexttaskiscreatingthenodes.Atfirst2Ctheservernodewillbecreated.Thistakestheresponse2Cdoessomecomputationandthenpassestheresultbacktotheclient.Thesource-codecanlooklikethis:" %)
(((
//The next task is creating the nodes. At first, the server node will be created. This takes the response, does some computation and then passes the result back to the client. The source-code can look like this~://
)))

(% class="box infomessage" %)
(((
#include "ros/ros.h"
#include "calculator/calc_srv.h"
#include &lt;string>

bool add(calculator::calc_srv::Request  &amp;request, calculator::calc_srv::Response &amp;response){
  response.sum = request.a + request.b;
  ROS_INFO_STREAM("The two integers are: " &lt;&lt; request.a &lt;&lt; " and " &lt;&lt; request.b &lt;&lt; "\n");
  ROS_INFO_STREAM("The calculated sum is " &lt;&lt; response.sum &lt;&lt; "\n");
  return true;
}

int main(int argc, char ~*~*argv)
{  
  ros::init(argc, argv, "server");
  ros::NodeHandle n;

  ros::ServiceServer service = n.advertiseService("calculate", &amp;add);  
  ROS_INFO_STREAM("Server ready.");  
  ros::spin();

  return 0;
}

 
)))

The first two lines include the required header files (% class="mark" %)ros/ros.h (%%)and the new (% class="mark" %)created calculator/calc_srv.h(%%)[^calc_header].
Following this, the function(% class="mark" %) bool add()(%%) is defined and declared. This will be used as a callback-function for the service-object. The function expects a request- and a response-object from the (% class="mark" %)class calculator::calc_srv(%%).
Inside the function, the two integers from the object req are added and passed to res.sum. Following, two info-messages are printed to the terminal telling the user what is going on.
The next step is the main-function. At first, the ROS node is initialized as usual. Then, a service-object is created with a member-function of the nodehandle. In the basic configuration it expects two arguments, a servicename and the callback-function. The servicename is chosen as calculate and the callback-function is the one created above. The info-message in the next line is not required, but it is good to know that the server is started.
(% class="mark" %)ros::spin()(%%) is already known from Example 4: Subcriber.


==== **Creating the client-node** ====

After the server-node is created successfully (but not build yet), the client-node follows. This will take the input from the commandline and pass the values to the server. After the computation in the server, the result will be passed back to the client. Then, the client will produce the output in the terminal.
So, the code for this task looks as follows:

(% class="box infomessage" %)
(((
#include "ros/ros.h"
#include "calculator/calc_srv.h"
#include &lt;boost/lexical_cast.hpp>

int main(int argc, char ~*~*argv){    
\\  if (argc != 3)
  {
    ROS_WARN_STREAM("Enter two int_numbers!");
    return 1;
  }

  ros::init(argc, argv, "calc_client");
  ros::NodeHandle n;  
  ros::ServiceClient client = n.serviceClient&lt;calculator::calc_srv>("calculate");  
  calculator::calc_srv srv;

try{
         srv.request.a = boost::lexical_cast&lt;int>(*(argv+1));
           srv.request.b = boost::lexical_cast&lt;int>(*(argv+2));
         }
  catch(const boost::bad_lexical_cast &amp;){
        ROS_ERROR_STREAM("Enter only INTs!");
        return 1;
      }
\\  if (client.call(srv))
  {
      ROS_INFO_STREAM("Result is: " &lt;&lt; srv.response.sum &lt;&lt; "\n");    
  }
  else{
    ROS_ERROR_STREAM("Something went wrong. Bad response from server.");
    return 1; }
  return 0;
}

 
)))


At the top, the library(% class="mark" %) ros/ros.h" (%%)is included as usual, when using the ROS C++-API. (% class="mark" %)calculator/calc_srv.h (%%)provides the informations about the service, which was created in srv-Typedefinition. The boost-library is required for the typecast, later in the code, and the related expection handling.
The main-function starts with a logical-check on the input. (% class="mark" %)argc(%%) contains the number of values entered in the commandline. The if-statement checks for three values, but the server adds only two. On first sight this seems wrong, but the first argument (or better, the zeroth element in the array argv) is always the path where the executable is located. Considering this it is obvious, that the right numbere of argmuents is three.
After this check, the node is created with(% class="mark" %) ros::init()(%%) and(% class="mark" %) ros::NodeHandle(%%). Subsequently the service-client is created in a similiar way as the service-serve. The client-object is initialized by a memberfunction of the nodehandle. At this point it is important to choose the same servicename as the server uses. In this case the right servicename is (% class="mark" %)calculate(%%).


Afterwards an object from (% class="mark" %)calculator::calc_srv(%%) is created. This is required for the next step, where the arguments from the commandline have to be casted from C-string to integer. For this purpose the boost- library provides the (% class="mark" %)lexical_cast&lt;T>()(%%)-function. This function casts the function-argument to the datatype T. If the input can not be casted as expected, the function throws an exception(% class="mark" %) boost::bad_lexical_cast(%%). So, the try-catch-instruction prevents from sending a bad commandline-input to the server.
However, when the commandline-input is correct the following if-statement is executed. In the Argument the call-function is called. The function returns a bool, so it can be used as an argument for the if-statement. If the callback-function add() returns true, the client-node writes the result to the commandline using a logging-message. Otherwise, when the callback-function returns false an error-message is printed in the terminal and the main-function returns with 1.


==== **build-process** ====

At this point the two sourcefiles have been created and stored in the src-directory inside the calculator-package. Before the build-process can start the file CMakeLists.txt has to be prepared.
At first open the CMakeLists.txt-file and uncomment the lines


(% class="box infomessage" %)
(((
add_service_files(
    FILES
 )
)))

Now add (% class="mark" %)calc_srv.srv (%%)under FILES. These lines make sure, that the .srv-file in the directory srv is considered during the build-process.

Further, the following lines have to be uncommented.

(% class="box infomessage" %)
(((
 generate_messages(
   DEPENDENCIES
 )
)))

These are required for generating the messages, that are defined inside the service-definition. In this case only standard messagetypes are used, so the only entry will be(% class="mark" %) std_msgs.(%%) This line has to be added under DEPENDENCIES.
The next step is to announce the sourcefiles to the build-process. It is important to remember, that the headerfiles calculator/calc_srv.h, which is included in both sourcefiles is not build yet. That is why it is necessary to add dependencies to the CMakeLists.txt-file. These dependencies make sure, that executables are only then be built, when the build of headerfile has finished.
The generic structure of the dependency-command is:

(% class="box infomessage" %)
(((
add_dependencies(&lt;target> &lt;target_dependency>)
)))

 In this case the proper command is:

(% class="box infomessage" %)
(((
add_dependencies(server calculator_generate_messages_cpp) # for the server
)))

or

(% class="box infomessage" %)
(((
add_dependencies(client calculator_generate_messages_cpp) # for the client
)))

 Maybe it seems a bit strange, that the dependency is related to message_generation and not about service-files. But message_generation works for both[^msg_and_srv]
With the knowledge from Example 2: hello-world.cpp, the following lines can be added to CMakeLists.txt:

(% class="box infomessage" %)
(((
add_executable(server src/server.cpp)
target_link_libraries(server ${catkin_LIBRARIES})
add_dependencies(server calculator_generate_messages_cpp)

add_executable(client src/client.cpp)
target_link_libraries(client ${catkin_LIBRARIES})
add_dependencies(client calculator_generate_messages_cpp)
)))

(% class="box" %)
(((
 Note: The file package.xml has not to be adjusted, because the required dependencies were added when the package was created.
)))

The verylast step is to start the build process. Switch to the top of the workspace and then execute 

(% class="box infomessage" %)
(((
catkin_make
)))


==== **Using the package** ====

After a successful build-process two executables are generated. Before they can be used a roscore has to be started. Afterwards, start the server-node with

(% class="box infomessage" %)
(((
$ rosrun calculator server
)))

and the cleint node with 

(% class="box infomessage" %)
(((
$ rosrun calculator client a b
)))

Replace a and b with integer values. For example, execute:

(% class="box infomessage" %)
(((
 $ rosrun calculator client 4 12
)))

This results in the following output in the server-terminal: 

(% class="box infomessage" %)
(((
[ INFO] [1509369925.682593826]: The two integers are: 4 and 12

[ INFO] [1509369925.682726903]: The calculated sum is 16
)))

The output in the client-terminal will be similar to: 

(% class="box infomessage" %)
(((
[ INFO] [1509369925.683124120]: Result is: 16
)))

Invalid inputs like

(% class="box infomessage" %)
(((
$ rosrun calculator client 4 xy
)))

or

(% class="box infomessage" %)
(((
$ rosrun calculator client
)))

will cause error-messages, due to the error-handling in the nodes. 


=== Example 6: Ask the master ===

----

This is another example for creating a service in a ROS-network. The node provides a service that should return the number of active topics in the ROS network.
At first a new package has to be created. The ROS C++-API is needed for sure and furthermore the standard ROS-messages. So, the command for creating the new package is (of course, this command should be executed in the source-folder of the workspace):

(% class="box infomessage" %)
(((
$ catkin_create_pkg list_topics roscpp std_msgs message_generation
)))

 The new package is called list_topics with the dependencies roscpp, message_generation and std_msgs.


==== **Define the service** ====

The next step is a new one. To define a service switch in the package folder and create a new folder called srv. Open this folder an create a new file. This file contains the definition of the service, i.e. the input and output arguments. This file will be named with "list_topics_service.srv".
Then, open the file and type in the definition of the service. The service does not need any input arguments. The output argument, what the service should return, is a single integer value. So, the definition looks like this:

(% class="box infomessage" %)
(((
~-~--
int16 number_of_topics
)))

The definition is to read as follows. Over the three hyphens there are the input argument(s). In this case it is empty, but also when it empty a messagetype will be required. This messagetype is std_msgs/Empty. Under the three hyphens are the output argument(s). As seen above, only one argument is listed. The output argument of this service is an 16bit integer called number_of_topics.
At this point the service is already defined.


==== **Creating the server** ====

After defining the service, a server that provides the service is necessary. For this purpsose change to the folder src within the package directory and create a file named "list_topics_node.cpp". The server, which provides the desired service, is created by the following code:

(% class="box infomessage" %)
(((
#include "ros/ros.h"
#include "list_topics/list_topics_service.h"

bool number_topics(list_topics::list_topics_service::Request &amp;req, list_topics::list_topics_service::Response &amp;res){
    ros::master::V_TopicInfo master_topics;
    ros::master::getTopics(master_topics);
    int number_t = master_topics.size();
    ROS_INFO("Topics: [%i]", (int) number_t);
    res.number = number_t;
  return true;
}

int main(int argc, char ~*~*argv)
{  
  ros::init(argc, argv, "list_topics_node");
  ros::NodeHandle handle;
\\  ros::ServiceServer service = handle.advertiseService("show_number_of_topics", &amp;number_topics);
  ROS_INFO("Returning number of active topics.");
  ros::spin();

  return 0;
}
)))

At the very top, the requiered libraries are included. ros/ros.h is necessary every time when the ROS C++-API should be used. The header list_topics/list_topics_service.h includes the service-definition. That there is no such headerfile build so far should be kept in mind for the later build-process.
Further down, the callback-function, that will be executed when the service is called, is defined. The returntype is always bool. It does not matter, whether it is a function or a member function or anything else.
The body of the callback-function contains the
instructions, that will be executed when a new request arrives. At the beginning a new vectorobject from the struct V_TopicInfo is created. In the next line the function getTopics (V_TopicInfo &amp;topics) writes all active topics to the vectorobject by reference. Because V_TopicInfo is just a vector of structs, the member function can be used here to return the size of the vector, which is equal to the number of active topics.
The last instruction in the callback-function is the return argument.
The main-function starts as usual with the initialization of the node. Afterwards the serive_serve is created. The ROS C++-API recommends to do this with the member function of the nodehandle.


(% class="box" %)
(((
A ServiceServer should always be created through a call to NodeHandle::advertiseService(), or copied from one that was. Once all copies of a specific ServiceServer go out of scope, the service associated with it will be unadvertised and the service callback will stop being called. (see: ros::ServiceServer Class Reference)
)))

There are several ways to implement a service. For this introductory example, the simplest option is to use a simple callback function. Only the service name and the name of the callback functions is expected.
Following, an info message that the service server is ready and the instruction to pass control to the node.
Now the node is almost ready to get build with catkin.


==== **Building the service-server** ====

Before the node can be build, the file CMakeLists.txt has to be adjusted.

(% class="box infomessage" %)
(((
cmake_minimum_required(VERSION 2.8.3)
project(list_topics)

find_package(catkin REQUIRED COMPONENTS
  message_generation
  roscpp
  std_msgs
)

add_service_files(
    FILES
      list_topics_service.srv
                )


 generate_messages(
   DEPENDENCIES
   std_msgs
                )

include_directories(
  ${catkin_INCLUDE_DIRS}
)


add_executable(list_topics_node src/list_topics_node.cpp)
target_link_libraries(list_topics_node ${catkin_LIBRARIES})
add_dependencies(list_topics_node list_topics_generate_messages_cpp)
)))

The required components have been added when the package has been created (see above). At first, catkin has to know that it has to create headerfiles from the service definition. This can be declared in section add_service_files. Further the message-dependencies have to be declared. As a reminder, the service definition is a composition of messages. In this case two standard messages are used. So, In section `generate_messages the entry std_msgs has to be made.
After including the catkin directory and adding the executable (see also: example-2-hello-worldcpp), a dependency has to be added, that the service header have to be build before building the executable. Otherwise the build process will throw an error.
After editing the CMakeLists.txt file the build process can start:

(% class="box infomessage" %)
(((
$ catkin_make
)))

(% class="box" %)
(((
Note: Usually the manifest package.xml has to be edited as well. But in this case, the required dependencies have been added by using the catkin_create_pkg command with the proper dependencies.
)))



==== **Using the package** ====

The service is quite simple to use. Open up three terminals and start a roscore in the first one. Than start with

(% class="box infomessage" %)
(((
$ rosrun list_topics list_topics_node
)))

the service-server node.
The last step is to call the service. With knowledge from the previous chapter, the command

(% class="box infomessage" %)
(((
$ rosservice call /show_number_of_topics
)))

should be familiar.



=== Further Examples ===

(% class="box" %)
(((
As said in the introduction, this is designed as rolling release. So, the number of examples and/or other sections will increase in future.
)))

==== **Spawn a turtle with a service** ====

Another good described example can be found in this free-of-charge book in chapter 8.3. In this example the author describes how to implement a node, that calls the service /spawn provided by the node /turtlesim_node. The proceeding is similar to the above one, but it may be a good exersise to implement it on your own.

1. Note: Calling(% class="mark" %) $ rosnode info &lt;node-name>(%%) will return the services provided by the node. ROS nodes
1. rosrpc stands for ROS-~_~_R~_~_emote ~_~_P~_~_rocedure ~_~_C~_~_all
1. The hyphens are not optional, rather part of the syntax.</content>
  <attachment>
    <filename>ros_service_basic_struture.png</filename>
    <versions>head	1.1;
access;
symbols;
locks; strict;
comment	@# @;


1.1
date	2019.10.31.12.37.07;	author root;	state Exp;
branches;
next	;


desc
@@


1.1
log
@ros_service_basic_struture.png
@
text
@&lt;attachment>
  &lt;filename>ros_service_basic_struture.png&lt;/filename>
  &lt;author>XWiki.DavidDudzik&lt;/author>
  &lt;date>1545220217000&lt;/date>
  &lt;version>1.1&lt;/version>
  &lt;comment/>
  &lt;content>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&lt;/content>
  &lt;filesize>8991&lt;/filesize>
&lt;/attachment>@
</versions>
    <author>XWiki.DavidDudzik</author>
    <date>1545220217000</date>
    <version>1.1</version>
    <comment/>
    <content>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</content>
    <filesize>8991</filesize>
  </attachment>
  <attachment>
    <filename>ros_service_graph.png</filename>
    <versions>head	1.1;
access;
symbols;
locks; strict;
comment	@# @;


1.1
date	2019.10.31.12.37.07;	author root;	state Exp;
branches;
next	;


desc
@@


1.1
log
@ros_service_graph.png
@
text
@&lt;attachment>
  &lt;filename>ros_service_graph.png&lt;/filename>
  &lt;author>XWiki.DavidDudzik&lt;/author>
  &lt;date>1545220848000&lt;/date>
  &lt;version>1.1&lt;/version>
  &lt;comment/>
  &lt;content>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&lt;/content>
  &lt;filesize>35423&lt;/filesize>
&lt;/attachment>@
</versions>
    <author>XWiki.DavidDudzik</author>
    <date>1545220848000</date>
    <version>1.1</version>
    <comment/>
    <content>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</content>
    <filesize>35423</filesize>
  </attachment>
</xwikidoc>